<!doctype html><html lang=en data-mode=dark><head prefix="og: http://ogp.me/ns#"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.120.4"><meta name=theme content="Color Your World -- gitlab.com/rmaguiar/hugo-theme-color-your-world"><title>Geometric Algebra | Topological 4-Geon Theory Unchained</title>
<meta name=author content="Bijou M. Smith"><meta name=robots content="index follow"><link rel=canonical href=https://t4gu.gitlab.io/t4gu/theory/004_geometric_algebra/><meta property="og:site_name" content="Topological 4-Geon Theory Unchained"><meta property="og:title" content="Geometric Algebra"><meta property="og:url" content="https://t4gu.gitlab.io/t4gu/theory/004_geometric_algebra/"><meta property="og:type" content="website"><meta name=twitter:dnt content="on"><meta name=theme-color content="#222"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebSite","url":"https://t4gu.gitlab.io/t4gu","inLanguage":"en","name":"Topological 4-Geon Theory Unchained","description":"Geon Theory Development","publisher":"Bijou M. Smith"}</script><link rel=stylesheet href=https://t4gu.gitlab.io/t4gu/css/main.min.d33233e3d0eb633ea1fbb9e17553fe7c8ff07875b91d8186e046a48480987c8e.css integrity="sha256-0zIz49DrYz6h+7nhdVP+fI/weHW5HYGG4EakhICYfI4=" crossorigin=anonymous><noscript><meta name=theme-color content="#26A269"><link rel=stylesheet href=https://t4gu.gitlab.io/t4gu/css/noscript.min.503f912ad7e7391597c629c1f7134b77fa61b200f7425671b8fbbe91f62ad657.css integrity="sha256-UD+RKtfnORWXxinB9xNLd/phsgD3QlZxuPu+kfYq1lc=" crossorigin=anonymous></noscript><link rel=preload href=/t4gu/fonts/OpenSans-Bold.ttf as=font crossorigin=anonymous><link rel=preload href=/t4gu/fonts/OpenSans-Italic.ttf as=font crossorigin=anonymous><link rel=preload href=/t4gu/fonts/OpenSans-Regular.ttf as=font crossorigin=anonymous><link rel=preload href=/t4gu/fonts/Oswald-Bold.ttf as=font crossorigin=anonymous><link rel=preload href=/libs/katex@0.16.0/dist/fonts/KaTeX_Main-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/libs/katex@0.16.0/dist/fonts/KaTeX_Math-Italic.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/libs/katex@0.16.0/dist/fonts/KaTeX_Size2-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/libs/katex@0.16.0/dist/fonts/KaTeX_Size4-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><script src=https://t4gu.gitlab.io/t4gu/js/main.6bc16541f8ff648cb50eea8924e00b94561cf02ec5b5c22ae4b3bce8bab38233.js integrity="sha256-a8FlQfj/ZIy1DuqJJOALlFYc8C7FtcIq5LO86LqzgjM=" crossorigin=anonymous></script></head><body><header><a href=/t4gu><img src=https://t4gu.gitlab.io/t4gu/images/t4gu_logo.svg alt="T4GU logo" style=display:flex;width:40px;height:34px;float:left;margin-bottom:-2.5px;margin-right:10px> </a><a href=/t4gu>Topological 4-Geon Theory Unchained</a><nav aria-label="Main menu."><ul><li><a class=btn href=/t4gu/>Home</a></li><li><a class=btn href=/t4gu/philosophy/>Philosophy</a></li><li><a class=btn href=/t4gu/theory/>Theory</a></li><li><a class=btn href=/t4gu/blog/>Posts</a></li><li><a class=btn href=/t4gu/contact/>Contact</a></li><li><a class=btn href=/t4gu/donations/>Donate</a></li></ul></nav></header><div class=filler><main><article><header><h1>Geometric Algebra</h1><p>Published on <time datetime=2016-10-24>2016-10-24</time></p></header><details class=toc open><summary class=outline-dashed>Contents</summary><nav id=TableOfContents><ul><li><a href=#a-new-langauge-or-the-language-for-physics>A New Langauge or <em>the</em> Language for Physics?</a></li><li><a href=#frame-basis-vectors>Frame Basis Vectors</a><ul><li><a href=#the-geometric-product>The geometric product</a></li><li><a href=#higher-grade-elements>Higher grade elements</a></li><li><a href=#the-alternative-starting-point>The alternative starting point</a></li><li><a href=#the-triple-products>The triple products</a></li><li><a href=#terminology-----blades-and-homogenous-multivectors>Terminology &mdash; blades and homogenous multivectors</a></li></ul></li><li><a href=#linear-algebra>Linear Algebra</a><ul><li><a href=#homegeneous-mixed-products>Homegeneous mixed products</a></li><li><a href=#algebra-of-the-plane>Algebra of the Plane</a></li><li><a href=#the-3-space-euclidean-algebra>The 3-space Euclidean algebra</a></li><li><a href=#the-pseudo-pauli-algebra>The pseudo-Pauli algebra</a></li></ul></li><li><a href=#bivector-algebra>Bivector algebra</a><ul><li><a href=#the-complex-structure-in-mathcalg3>The &ldquo;complex&rdquo; structure in $\mathcal{G}^3$&mldr;</a></li></ul></li><li><a href=#reflections-and-rotations>Reflections and Rotations</a><ul><li><a href=#reflections>Reflections</a></li><li><a href=#rotations>Rotations</a></li><li><a href=#Rotations-from-bivectors>Rotation in terms of the bivector and the angle</a></li></ul></li><li><a href=#rotors-transform-single-sided-under-some-other-rotation>Rotors transform single-sided under some other rotation</a></li><li><a href=#rotors-transform-single-sided>Rotors transform single-sided</a><ul><li><a href=#take-a-random-rotor-r>Take a random rotor $R$</a></li><li><a href=#lie-group-generators>Lie group generators</a></li></ul></li><li><a href=#quick-note-projective-and-conformal-geometry>Quick Note: Projective and Conformal Geometry</a><ul><li><a href=#motivations>Motivations</a></li><li><a href=#resources>Resources</a></li></ul></li><li><a href=#lorentz-rotations>Lorentz Rotations</a><ul><li><a href=#a-z-boost>A $z$ Boost</a></li></ul></li><li><a href=#more-to-come->More to Come &mldr;</a></li><li><a href=#software>Software</a><ul><li><a href=#python-galgebra>Python galgebra</a></li><li><a href=#kingdon-geometric-algebra>kingdon Geometric Algebra</a></li><li><a href=#julia-multivectors>Julia Multivectors</a></li></ul></li><li><a href=#caveats>Caveats</a></li></ul></nav></details><p>If you are not satisfied with this introduction please consider getting the textbook
<a href=https://www.cambridge.org/core/books/geometric-algebra-for-physicists/FB8D3ACB76AB3AB10BA7F27505925091 target=_blank>Geometric Algebra for Physicists,</a>
or browse the collection of free articles on the
<a href=http://geometry.mrao.cam.ac.uk/ target=_blank>Cambridge GA group website</a>
or on <a href=http://geocalc.clas.asu.edu/ target=_blank>David Hestenes' website.</a></p><h2 id=a-new-langauge-or-the-language-for-physics><a class=anchor href=#a-new-langauge-or-the-language-for-physics title='Anchor for: A New Langauge or the Language for Physics?.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>A New Langauge or <em>the</em> Language for Physics?</h2><p>Geometric Algebra is described by Hestenes, Doran and Lasenby as the <em>unified
language for physics</em>. But in my view it is tantamount to <em>the</em> language, and
that&rsquo;s because I think all physics is geometry. But if you do not take such an
extreme view, a &ldquo;unified language&rdquo; is good enough to warrant learning
$\mathcal{GA}$.</p><p>For a great lunch-time video on this (or two or three lunch breaks) I would
recommend
<a href="https://www.youtube.com/watch?v=m7v2IUJtC3g" target=_blank>Anthony Lasenby's</a>
talk at GAME2020
<a href="https://www.youtube.com/watch?v=m7v2IUJtC3g" target=_blank>A new language for physics,</a>
and
if you have a few more lunch breaks free try this one on
<a href="https://www.youtube.com/watch?v=fFj4E7q4hbY" target=_blank>GA and Fundamental forces.</a></p><p>Lasenby begins with the simple idea of composing words out of vectors,
so take $\vec{a}$ and $\vec{b}$ in any space, and then say the &lsquo;word&rsquo; &ldquo;$ab$&rdquo; is
in our dictionary such that,
$$ ab = -ba \quad\text{iff $a$ and $b$ are perpendicular}
$$
and
$$ ab = |a||b|\quad\text{iff $a$ and $b$ are parallel}
$$
where $|v|$ denotes the length of a vector $\vec{v}$.</p><p>This already gives us impressive powers of expression if we know a little bit
of Euclidean geometry. For instance, if we have an orthonormal frame of
vectors, say
$\{e_1, e_2\}$, then we immediately get part of the Pauli algebra,
$$ e_1e_1 = e_1^2 = 1, \qquad\text{and}\qquad e_1e_2 = -e_2e_1.$$
Then already we&rsquo;ve got this word which squares to $-1$,
$$ I=e_1e_2, \quad\Rightarrow \quad I^2 = (e_1e_2)(e_1e_2) = -e_1^2 e_2^2 = -1 $$</p><p>Then we&rsquo;ve got words like,
$$ x + y(e_1e_2) $$
which used to be called &ldquo;complex numbers&rdquo; but which we now see are natural
and part of an <em>even sub-algebra</em> of space, since they are a sum of a scalar
and a bivector.</p><p>What about the &ldquo;words&rdquo;,
$$ \tfrac{1}{2}(ab + ba)\qquad\text{and}\qquad \tfrac{1}{2}(ab - ba) $$
well, with not much effort we see these are respectively symmetric and
antisymmetric, and so can be used to define a scalar or inner product (the
first expression) and an anti-symmetric outer product (the second expression).</p><p>This is regardless of the relative orientation of $a$ and $b$, since we can
decompose each into perpendicular and parallel parts, then use the first two
words above.</p><p>So we add two new words to our dictionary, for &ldquo;inner product&rdquo; and &ldquo;outer
product&rdquo;,
$$ \begin{array}{rl}
a\cdot b \!\!\! &= \tfrac{1}{2}(ab + ba) \\
a\wedge b \!\!\! &= \tfrac{1}{2}(ab - ba) \\
\end{array}
$$
Furthermore, we now have for free the word,
$$ ab = a\cdot b + a\wedge b$$</p><p>Watch that first video above for more.</p><h2 id=frame-basis-vectors><a class=anchor href=#frame-basis-vectors title='Anchor for: Frame Basis Vectors.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Frame Basis Vectors</h2><p>Local differentiable physics can be performed with a <strong><em>graded</em></strong> algebra.
For this we use a Euclidean or Minkowski basis.
For computational robotics and computer graphics one would only use the Euclidean frame ${\vec{e}_1, \vec{e}_1, \vec{e}_3 }$ which are a set of
basis vectors in a cartesian system $(x,y,z)$.</p><p>For physics it is easier to begin with the spacetime algebra, since we will
want to go straight to a Measurement Theory (i.e., quantum mechanics (QM)).
The reason for this is that the Pauli algebra is best treated as an algebra of
spacetime bivectors, <strong><em>not</em></strong> pure space vectors.
This should be a strong hint to you that quantum mechanics is from the very
start a space+time theory.
That is to say, even in the Schrödinger and Pauli theory we are really always
doing relativity, and the orthodox matrix algebra treatments obscure this fact.</p><p>We start then with the frame basis:
$$ \{ \vec{e}_0, \vec{e}_1, \vec{e}_1, \vec{e}_3 \}\quad
\text{where}\quad e_0^2=-1,\quad\text{and}\quad e_i^2=1\quad \text{for $i\ne 0$}.
$$</p><p>Any vector can be expanded in this basis locally:
$$
a = a^\mu e_\mu
$$
and unless otherwise necessary we drop the over-arrow symbol on our vectors, so
$a=\vec{a}$.
The magnitude of such a vector will be $|a|$.</p><p>When we do spacetime physics, relativistic QM in particular, the convention is
to change symbols for the basis vectors from $e_\mu$ to $\gamma_\mu$.
This is nothing more than a convention, and is made in deference to
Paul Dirac who labelled his matrices $\hat{\gamma}$.</p><p>The deference being a lot more than symbolic, since the Dirac matrices do in
fact map onto the spacetime algebra $\gamma_\mu$ base vectors! We will see
this in a later chapter.</p><h3 id=the-geometric-product><a class=anchor href=#the-geometric-product title='Anchor for: The geometric product.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>The geometric product</h3><p>A <em>geometric product</em> is then defined frame-free by a decomposition
into symmetric and anti-symmetric parts,
$$ ab = a\cdot b + a\wedge b $$
The symmetric part $a\cdot b$ is the usual inner product.
The anti-symmetric part is the outer product.
This means $a\wedge b = -b \wedge a$.</p><p>If $a$ and $b$ are parallel or anti-parallel we will fail to generate a
non-zero bivector and then $a\wedge b$ will be identically $=0$.
The modulus of <em>any</em> bivector is equal to the area of the parallelogram
formed by the two vectors.
$$
|a\wedge b| = |a||b|\sin\theta
$$
where $\theta$ is the angle between, or spread of, $a$ and $b$.</p><p>If $a$ and $b$ are perpendicular we will fail to generate a non-zero scalar
and $a\cdot b$ will be identically $=0$. The modulus of <em>any</em> inner product
is equal to the length of one of the pair projected onto the direction of
the other scaled by the modulus of the other, that is,
$$
|a\cdot b| = |a||b|\cos\theta
$$
where $\theta$ is again the spread angle.</p><h4 id=associativity><a class=anchor href=#associativity title='Anchor for: Associativity.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Associativity</h4><p>Unless you are doing weird sh*t, associativity is a good property to have,
especially for quantum mechanical operators.
But we cannot derive it from the previous definitions
(at least I do not think we can, since non-associative algebras are known),
so we <em>demand associativity</em> of the geometric product as an axiom for the GA.
$$ a(bc) = (ab)c = abc.$$</p><p>This nicely extends to higher grades directly from associativity for the basis
vectors,
so for <em>any</em> multivectors,
$$ A(BC) = (AB)C = ABC. $$</p><p><strong>Comment:</strong> we did not need associativity to plough ahead,
but we&rsquo;re interested in <em>physics</em> and later on we will justify the choice of
the associative axiom when we arrive at the knowledge in GA the multivectors
are the objects we use both for the physical <strong>states</strong> and <em>also</em> for the
linear <strong>operators</strong>.
But the linear operators are measurement <strong><em>processes</em></strong> (abstractly speaking).
And all known physical processes are associative (in the abstract).
This is why our axiom of associativity is ultimately justified.
But we need to do several chapters of ground work before we come
full virtuous circle on that. I&rsquo;m just looking a long way ahead in this
comment.</p><h4 id=division-by-vectors><a class=anchor href=#division-by-vectors title='Anchor for: Division by vectors.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Division by vectors</h4><p>One powerful feature of any GA is we can divide by non-zero vectors, just use
the inverse:
$$ b^{-1} \equiv \frac{b}{|b|^2} = \frac{b}{b^2}.$$</p><p>Here the denominator $b^2 = b\cdot b = |b|^2$ from the definitions.</p><h3 id=higher-grade-elements><a class=anchor href=#higher-grade-elements title='Anchor for: Higher grade elements.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Higher grade elements</h3><p>Higher grade multivectors can be bult by combinations of simple summing and
further wedging. So for example, in 3D spaces we can form a trivector, which
is an oriented 3-volume, from a wedge of 3 non-coplanar vectors, say $a$,
$b$ and $c$.
$$ T = a \wedge b \wedge c $$</p><p>If $\{a, b, c \}$ are co-planar then $T=0$ identically and so we fail to
generate a trivector, or should we say, &ldquo;we fail to generate a significant
trivector.&rdquo;</p><p>The modulus of a trivector is proportional to a determinant for a 3-volume.</p><p>We can continue wedging basis vectors until we hit the dimension of the space.
For physics this will normally be $D=4$.</p><blockquote><p>In 4D spacetime we have five grades,
$$ \text{scalar, vectors, bivectors, trivectors, pseudoscalar.} $$</p></blockquote><p>The pseudoscalar $i=e_0e_1e_2e_3$ is the unit quadvector or 4-vector, which
risks getting confused with the simple 1-vector in special relativity.</p><blockquote><p>In special relativity &ldquo;spacetime&rdquo; vectors like $(E,\vec{p})$ are just
called 1-vectors in STA.</p></blockquote><p>All 1-vectors thus have the dimension of the spacetime.
Whereas 4-vectors or quadvectors are graded, they are elements of a 4D
spacetime hypervolume or hypercube (the shape though is irrelevant).</p><p>We have already defined a lot of terms.
I will use distinct definition paragraphs in these lectures only for emphasis,
which in GA is important because most undergraduate students are
thoroughly unfamiliar with the notation and lexicon.</p><p><strong>Definition:</strong> The 4-spacetime pseudoscalar is denoted $i$, and is defined by,
$$ i \equiv e_0e_1 e_2 e_3.$$
It is an oriented 4-volume.</p><p>You might think the 3-space pseudoscalar aught to be something
like $I=e_1e_2e_3$, which is ok, ok for doing robotics and stuff.
But in physics we will see later on that it makes more sense to define a
pseudoscalar for relative vectors (which are actually bivectors) which
<em>anticommutes</em> with vectors, and so for a lot of physics we will use,
$$
I = (e_0e_1)(e_0e_2)(e_0e_3) = i
$$
for doing non-relativistic quantum mechanics.
If you are strictly doing classical mechanics it is fine to use the oriented
unit 3-volume $I=e_1e_2e_3$.</p><p>What do we mean by &ldquo;oriented&rdquo;?</p><p>We mean that the quantity will change sign upon any odd permutation,
in particular a single pair permutation, similarly to a bivector.
Bivectors are oriented.
The parallelogram formed by $a\wedge b$ is different to that formed by $b\wedge
a$ by an orientation.</p><p>So, for instance, $e_1e_2e_3 = -e_2 e_1e_3$.</p><p>This is useful in a boat load of geometry, for instance with rotations, in
the GA it is far simpler to think in terms of the plane of rotation, which
is a bivector, rather than the axial vector (a normal to the plane).
So a rotation (to be later defined) by a bivector $a\wedge b$ is only
&ldquo;clockwise&rdquo; relative to some reference frame given by some axial vector,
whereas the counterclockwise rotation is produced by $b\wedge a$ so no
axial vector is needed (there is always one if we want it).</p><p>Got it? So in GA the bivector alone is sufficient to define the sense of the
rotation, it encodes angle, plane and direction. The lot! Nice huh?</p><p>That is, GA and STA are powerful enough to very simply identify &ldquo;top&rdquo; and
&ldquo;bottom&rdquo; of surfaces, and &ldquo;left-handed&rdquo; and &ldquo;right-handed&rdquo; for Euclidean
3-volumes. The entire theory of determinants can be developed from this
realization (we will not do so here). Soon we will see this provides us
with several (not just one) &ldquo;complex structures,&rdquo; which does not mean
&ldquo;complicated&rdquo; it just means planar projected geometry.</p><p>I will denote the 3-space algebra $\mathcal{G}^3$, and the
(3+1)-spacetime algebra $\mathcal{G}^{1,3}$ or by the other abbreviation
STA. Even and Odd sub-algebras are denoted
$\mathcal{G}^+_n$ and
$\mathcal{G}^-_n$
respectively.</p><h3 id=the-alternative-starting-point><a class=anchor href=#the-alternative-starting-point title='Anchor for: The alternative starting point.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>The alternative starting point</h3><p>We decided to begin by defining the geometric product as a sum of symmetric and
antisymmetric parts. But we can now also show an equivalent development, which
would be to &lsquo;reverse engineer&rsquo; the previous and start by defining,
(<a name=eq_inner-and-outer-prod>Eq.1</a>)
$$ \begin{array}{rl}
a\cdot b \!\!\!&= \tfrac{1}{2}(ab + ba), \\
a\wedge b \!\!\!&= \tfrac{1}{2}(ab - ba).
\end{array}$$
and we would obtain exactly the same algebra.
From our previous starting point these are useful identities, holding for
1-vectors, $a$ and $b$.</p><p>We <strong><em>cannot</em></strong> define inner and outer products for higher grade objects
using the same definitions, which you will see if you try. However, we
can define the inner and outer products, it will just be done in a
subtly different, but easy to remember, way</p><h3 id=the-triple-products><a class=anchor href=#the-triple-products title='Anchor for: The triple products.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>The triple products</h3><p>There are several more &ldquo;products&rdquo; in geometric algebra than just (i)
the geometric, (ii) the inner, and (iii) the outer.
Further products occur when we consider the higher grades.
So, for instance, there is a dot product with a bivector,
$$
a\cdot (b \wedge c), \quad\text{and things like,}\quad a\wedge(bcd),\quad\text{and
whatnot.}
$$</p><p>We will not cover all the different types of product.
But just <strong><em>take careful note</em></strong> that for a commonly employed type,
the geometric products formed from 1-vectors and bivectors,
there is a symmetric/anti-symmetric split,
but <strong><em>it has the opposite signs</em></strong> to the vector geometric product,
thus we define, for any vector $a$ and bivector $B$,
(<a name=eq_bivector_prods>Eq.2</a>)
$$
\begin{array}{rl}
a\cdot B \!\!\!&= \tfrac{1}{2}(aB - Ba) \\
a\wedge B \!\!\!&= \tfrac{1}{2}(aB + Ba)
\end{array}
$$
compare closely with <a href=#eq_inner-and-outer-prod>Eq.1.</a>
By expanding in some randomly chosen basis vectors you can check for yourself
$a\cdot B$ is indeed symmetric, and $a\wedge B$ is anti-symmetric.</p><p>With a bit more work we can get identities for expressions like
$a\cdot b\wedge c$.</p><p>I want to jump straight to a few generalizations for any space dimension,
which introduces the full multivector algebra.
But first some <em>vital</em> terminology (don&rsquo;t skip).</p><h3 id=terminology-----blades-and-homogenous-multivectors><a class=anchor href=#terminology-----blades-and-homogenous-multivectors title='Anchor for: Terminology &mdash; blades and homogenous multivectors.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Terminology &mdash; blades and homogenous multivectors</h3><p><strong>Notation:</strong> the $e_1$ component (or $x$ component) of the vector $a$ could
be denoted $(a)_1$, but sometimes we use the Einstein index notation $a^i$,
so that we can expand in a frame basis $\{\vec{e}_i\}$ with the
summation notation,
$$
a = a^i e_i
$$
In the full geometric algebras we need different notation for picking out
grades of a multivector. For instance, we can add and subtract different
grades,
$$
M = a(b + bc)
$$
this multivector $M$ will in general have three grades: scalar, bivector and
trivector (depending on the orthogonality of $a$, $b$ and $c$).</p><p><strong>Definition:</strong> Grade projection is denoted by the symbol
$\langle M \rangle_n$ where this denotes &ldquo;picking out only the grade-$n$
parts of the multivector $M$.&rdquo;</p><p>If you do more than a lot of mathematics with GA, you should find a lot
of proofs can be amazingly simplified by using these
<em>grade projection operators</em>. They are nothing fancy, they just do what
they say: pick out one particular grade. Here is why they are so useful:</p><blockquote><p>As in Type theory, all geometric algebra identities are also identical
grade-by-grade.</p></blockquote><p>For example, suppose,
$$ A = 2.5 + \sqrt{2}\, e_1e_2 + (1+\pi^2) e_2e_3 - 1.06\, e_1e_2e_3 $$
then we have,
$$\begin{array}{rl}
\langle A\rangle_0 \!\!\!&= 2.5 \\
\langle A\rangle_1 \!\!\!&= 0 \\
\langle A\rangle_2 \!\!\!&= \sqrt{2}\, e_1e_2 + (1+\pi^2) e_2e_3 \\
\langle A\rangle_3 \!\!\!&= - 1.06\, e_1e_2e_3 \\
\langle A\rangle_4 \!\!\!&= 0 i
\end{array} $$
and if,
$$
B = 3 A,\quad \text{then,}\quad \langle B \rangle_0 = 7.5,
\quad \langle B \rangle_1 = 0,\quad\text{etc.}
$$
Note the grade projection does not convert to scalars, it retains the grade
structure. Meaning we can always expand multivectors,
$$
A = \sum_{n\in\{0,\ldots D\}} \langle A \rangle_n
$$
if we wanted to.</p><p><strong>Terminology:</strong> The concept of $n$-blade or $k$-blade. Here $n$ or $k$
are just whole numbers, from $0$ to $D$. If a multivector, like $A$ above
is found to have only non-zero components in a single grade, say $k$ then
we call it a $k$-blade.</p><p>You can convince yourself that saying &ldquo;$M$ is a $k$-blade&rdquo; is the same
as saying $M$ can be written as a single wedge product of three vectors,
say,
$$
M = a\wedge b \wedge c
$$</p><p><strong>Terminology:</strong> A &ldquo;simple $k$-vector&rdquo; is the same as some $k$-blade.</p><p>For example,
$$ M = \sqrt{3}\, e_1e_2 + 4 e_2e_3 $$
is a bivector, and also a 2-blade, because of the $e_2$ in common we can write,
$$
M = e_2 (4e_3 - \sqrt{3} e_1).
$$</p><p>We have to go to 4D before we can find a homogeneous grade-2 multivector
that is not a pure blade, for example,
$$
M = 5 e_1 \wedge e_2 + 2 e_3\wedge e_4
$$
is definitely <em>not</em> a 2-blade, because we cannot find two vectors
whose wedge product is this $M$. (Try it!) If you can find two 1-vectors
such that $M=a\wedge b$ then you&rsquo;ve made a mistake somewhere.</p><p>The reason in 3D we always get pure 2-blades is because the frame vectors
have a common point, the origin, and any two planes sharing a common point
must share a common line, so we can always factorise the bivector.</p><p><strong>Terminology:</strong> A multivector composed of sums of blades
<em>all of the same grade</em> is called <strong>homogeneous</strong>.</p><p>For example, above, $ M = \sqrt{3}\, e_1e_2 + 4 e_2e_3$ is homogeneous
of grade=2.</p><p>Note, if we want to label distinct 1-vectors but use the same roman letter,
say $a_1$ and $a_2$ we run into a clash with grade projection and scalar
components. That is why the bra-kets &ldquo;$ \langle\,\rangle_k $&rdquo; are used
for grade projection, and superscripts used for components &mdash; should
this clash become an issue for you.
You could also use round brackets &ldquo;$(\,)_k$&rdquo; for components, as I will
do below in proving $ia = -ai$.</p><p>Alternatively, you can avoid this by using the vector symbol, so write
$\vec{a}_1$ and $\vec{a}_2$. Which convention you use is up to you.
Mostly I will just try to not run out of roman letters.</p><h4 id=multivector-products><a class=anchor href=#multivector-products title='Anchor for: Multivector products.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Multivector products</h4><p>Consider a blade of grade $r$, denoted $A_r$, it has a symmetric and
anti-symmetric product with any 1-vector,
$$
\begin{array}{rl}
a\cdot A_r \!\!\!&= \frac{1}{2}(aA_r - (-1)^r A_r a) \\
a\wedge A_r \!\!\!&= \frac{1}{2}(aA_r + (-1)^r A_r a)
\end{array}
$$
It is a good exercise to show these are respectively symmetric and
antisymmetric, and in particular they reduce to
<a href=#eq_inner-and-outer-prod>Eq.1</a>
when $r=1$
(when $A$ is a 1-vector) and to <a href=#eq_bivector_prods>Eq.2</a>
when $r=2$
($A$ is a bivector).</p><p>In the case of the full multivector algebra we take these as definitions of
the inner and outer products, without defining the geometric product,
but now we just define the geometric product by,
<a name=eq_aAr_geomprod>(Eq.3)</a>
$$ a A_r = a\cdot A_r + a\wedge A_r$$</p><p>Since these two terms have distinct grades we can also write,
$$
a\cdot A_r = \langle a A_r\rangle_{|r-1|},\qquad\text{and}\qquad a\wedge A_r
= \langle a A_r\rangle_{|r+1|}.
$$</p><p>This use of grade projection facilitates more general GA expressions.</p><h4 id=the-commutator--product><a class=anchor href=#the-commutator--product title='Anchor for: The commutator  product.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>The commutator product</h4><p>In physics application and group theory it is very useful to use the
<strong>commutator</strong> product,
$$
A\times B = \tfrac{1}{2}\bigl(AB - BA\bigr)
$$
it comes up a lot, and is defined here for <em>any</em> two multivectors.</p><p>From the commutator we get a Jacobi identity,
$$
A\times (B\times C) + B\times (C\times A) + C\times (A\times B) = 0.
$$</p><p>A useful identity for 1-vectors and bivectors is,
$$
B\times a = \tfrac{1}{2}\bigl(B\times a - a\times B\bigr) = B\cdot a
$$</p><h4 id=duality-in-3d><a class=anchor href=#duality-in-3d title='Anchor for: Duality in 3D.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Duality in 3D</h4><p>The pseudoscalar is often used to make duality transforms,
e.g., in 3-space from 1-vectors to bivectors,
$$
Ia = A
$$
here $a$ is a vector, $I=e_1e_2e_3$ and $A$ is a bivector dual to $a$.
Also, $\vec{a}$ can be thought of as the axial vector associated with
the bivector plane of $A$.</p><h4 id=duality-in-4d><a class=anchor href=#duality-in-4d title='Anchor for: Duality in 4D.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Duality in 4D</h4><p>In spacetime the duality is between vectors and trivectors.
$$
i v = V_{r=3}
$$
where $i=\gamma_0\gamma_1\gamma_2\gamma_3$.
This makes the basis blades nicer to define in a given spacetime frame,
since we can get,
$$
\begin{array}{ccccc}
1\quad& \{\gamma_\mu\} & \{\gamma_\mu\wedge\gamma_\nu\} & \{i\gamma_\mu\}
& i \\
\text{one}\quad & 4 & 6 & 4
& \text{one} \\
\text{scalar}\quad & \text{vectors} & \text{bivectors} & \text{trivectors}
& \text{pseudoscalar}
\end{array}
$$</p><h2 id=linear-algebra><a class=anchor href=#linear-algebra title='Anchor for: Linear Algebra.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Linear Algebra</h2><p>Those above are many of the essential tools of linear algebra in $\mathcal{GA}$
and <em>all without</em> matrices.
So we can get adjoints, further dualities, all the involutions, Ideals,
discriminants, determinants, traces, eigenvalues and eigen-multivectors,
spectral theorems, spectral decompositions, and anything you can find in an
advanced linear algebra course.</p><p>There are also very useful similarity transforms and distinct operations
like spacetime inversion, space-inversion, conjugation and reversion &mdash;
which are all very similar operations &mdash; and incredibly useful.</p><p>This beats having only a mere complex conjugate if we were doing boring
$\mathbb{C}$ algebra over a $\mathcal{V}$.</p><p>One of these, a parity operator, simply switches coordinates of a pair of
coupled 4-geons.
That we will learn is useful in obtaining the Pauli Exclusion principle from
next to nothing (&ldquo;nothing&rdquo; except wading through all this preliminary work!).
But we&rsquo;ll save that for a later chapter.
The basic calculus is important for Lie group theory, so we&rsquo;ll eventually have
to tackle it, but not too soon.</p><p>The reference for almost all the useful linear algebra (for physicists) is
Chapter 4 of
<a href=https://www.cambridge.org/core/books/geometric-algebra-for-physicists/FB8D3ACB76AB3AB10BA7F27505925091 target=_blank>Lasenby and Doran</a>
or the free online paper by
<a href=https://core.ac.uk/download/pdf/82121095.pdf target=_blank>Hestenes, here.</a></p><h3 id=homegeneous-mixed-products><a class=anchor href=#homegeneous-mixed-products title='Anchor for: Homegeneous mixed products.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Homegeneous mixed products</h3><p>Suppose we have two homogeneous multivectors of grades $r$ and $s$ say,
$A_r$ and $B_s$.</p><p>Then upon some thought we can ascertain their geometric product will contain
terms of grades from $|r-s|$ to $|r+s|$ but skipping a grade each level,
in other words, we know we can write,
$$
A_r B_s = \langle A_rB_s\rangle_{|r-s|} + \langle A_rB_s\rangle_{|r-s|+2} +
\ldots + \langle A_rB_s\rangle_{|r+s|}
$$
(the key bit is the $+2$ not plus one on the second term, the pattern goes
up like that in steps of grade $2$ until $|r+s|$.)
Note also the symmetry.
It does not matter if $r &lt; s$,
we get the same expansion from the magnitudes on the
subscripts.</p><p>It is a longish but not too hard exercise to convince yourself this is true.</p><p>If you get stuck consult
<a href=https://www.cambridge.org/core/books/geometric-algebra-for-physicists/FB8D3ACB76AB3AB10BA7F27505925091 target=_blank>Lasenby and Doran Chapter 4</a>
or the free online paper by
<a href=https://core.ac.uk/download/pdf/82121095.pdf target=_blank>Hestenes, here.</a></p><p>That&rsquo;s almost all we need for the algebra, since <em>any</em> general multivector
is just a sum of these homogeneous types. It only leaves undone any
<em>geometric calculus</em>, which is a little bit harder to grok, and so we
will leave calculus aside for a later chapter.</p><p>I will refrain from going through more of this foundational slog.
Instead if we need any special results or spiffy identities we will reference
them from the textbook when needed.</p><p>Although, I am pretty sure I forgot something crucial in this foundational
stuff. Let me know if I did.</p><h4 id=exercises><a class=anchor href=#exercises title='Anchor for: Exercises.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Exercises</h4><p><strong>Exercise 1.</strong> Convince yourself the (3+1)-spacetime pseudoscalar $i$ is well-
defined, that is, it can only be grade=4.</p><p><strong>Exercise 2.</strong> Show that $i^2=-1$, and also $I^2=-1$, for the Euclidean
3-space $I=e_1e_2e_3$.
But also check that while $i$ anti-commutes with vectors, $I$ does not,
it commutes with vectors, when computing geometric products.</p><p>(These commutation/anti-commutation relations will turn out to be the classical
geometry source of &ldquo;quantum mechanics&rdquo; Lie group algebras.
Which will eventually back-up our claim that most of quantum mechanics is
classical geometry, albeit a bit gnarly, as per T4G postulates.)</p><p>For the anti-commutativity of $i$, for example,
although $ i a = e_0e_1e_2e_3 (a^0e_0+a^1e_1+a^2e_2+a^3e_3)$, we can
without loss of generality (w.l.o.g) just do this for one space coordinate
frame component, say $a^1e_1$,
$$\begin{array}{rl}
i (a)_1 \!\!\!&= e_0e_1e_2e_3 a^1 e_1 \\
&= a^1 e_0e_1e_2e_3 e_1, \quad\text{(scalars commute with everything)} \\
&= - a^1 e_0e_1e_2e_1 e_3 \\
&= + a^1 e_0e_1e_1e_2 e_3 \\
&= - a^1 e_1e_0e_1e_2 e_3 = - (a)_1 i
\end{array} $$
You can check for yourself the same result happens with $a^0e_0$, $a^2e_2$
and $a^3e_3$, but why bother? All you&rsquo;d be doing is changing a symbol.</p><p>Above we are of course using the geometric product definition, according
to which,
$$ e_1 e_2 = e_1\cdot e_2 + e_1\wedge e_2 = 0 + e_1\wedge e_2 = -e_2 e_1.$$</p><h3 id=algebra-of-the-plane><a class=anchor href=#algebra-of-the-plane title='Anchor for: Algebra of the Plane.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Algebra of the Plane</h3><p>Using basic combinatorics and the orthogonality relations defined for the
frame $\{e_i\}$ and the geometric product on the frame, we can easily see
in Euclidean 2-space the geometric algebra has the following
primitive elements:
$$ \begin{array}{ll}
\text{1 unit scalar}, & 1 \\
\text{2 basis vectors}, & \{e_1, e_2\} \\
\text{1 pseudoscalar}, & e_1e_2
\end{array}
$$</p><p>So we count all the elements from $2^D$, making $\mathcal{G}_2$ a $2^2 = 4$
dimensional algebra. Each grade $n$, has $\left(\begin{smallmatrix} D \\ n
\end{smallmatrix}\right)$ basis $n$-blades.</p><p>This forms a complex structure isomorphic to $\mathbb{C}$ if we use the even
subalgebra.</p><p><strong>Definition:</strong> The <em>even subalgebra</em>, denoted $\mathcal{G}^+$ or sometimes
$\mathcal{R}^+$, is the closed algebra of all even grade elements in any
geometric algebra.</p><p>So, the 1-vectors do not appear at all in the complex structure in Euclidean
$2$-space.</p><p>Due to this isomorphism we <em>could</em> call $\mathcal{G}^+_2$
&ldquo;the complex numbers,&rdquo; but the same structure recurs in all sorts of places
in higher dimensional Clifford geometric algebra, so we refrain from
doing so. <strong><em>There is no unique $\mathbb{C}$ in GA.</em></strong></p><p><strong>Exercise 3.</strong> Show the even subalgebra of $\mathcal{G}^2$ is closed
under geometric and inner and outer products.</p><h3 id=the-3-space-euclidean-algebra><a class=anchor href=#the-3-space-euclidean-algebra title='Anchor for: The 3-space Euclidean algebra.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>The 3-space Euclidean algebra</h3><p>Using basic combinatorics and the orthogonality relations defined for the frame
$\{e_i\}$, we can easily see in Euclidean 3-space the geometric algebra has
the following primitive elements:
$$
\begin{array}{ll}
\text{1 unit scalar}, & 1 \\
\text{3 basis vectors}, & \{e_1, e_2, e_3\} \\
\text{3 basis bivectors}, & \{e_1e_2, e_2e_3, e_3e_1\} \\
\text{1 pseudoscalar}, & I=e_1e_2e_3
\end{array}
$$
So we have a $2^3 = 8$ dimensional algebra.
And the binomial coefficients again agree with the number of primitive blades.</p><p>These combinatorics generalize to any whole number $D$ of space dimensions,
and for any metric signature.</p><h4 id=special-dualities-in-3d><a class=anchor href=#special-dualities-in-3d title='Anchor for: Special Dualities in 3D.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Special Dualities in 3D</h4><p>I may have mentioned under <a href=#linear-algebra>Linear Algebra</a>
that duals
appear naturally in GA, one type of duality is simply &ldquo;multiplication by
the pseudoscalar.&rdquo;
$$ \text{dual}(A) = i A $$
However, <strong><em>only in 3D</em></strong> do we find a special duality between vectors
and bivectors, which is that the dual of a vector is a bivector:
$$
\begin{array}{rl}
\text{in } \mathcal{G}^3:\quad I e_1 \!\!\!&= e_2e_3 \\
\text{or,}\quad I e_k \!\!\!&= e_ie_j,\qquad\text{cyclic on }i,j,k\in\{1,2,3\}
\end{array}
$$</p><p>This is not really &ldquo;special&rdquo;, it is more of a trap for the unwary, since it
is the source of why quaternions were miss-used, and why the foolish use
Gibbs axial vectors for rotations.
The axial vector only works in 3D.
Whereas in general $n$-D spaces the rotations are always completely
specified by a single bivector!
(See section <a href=#Rotations-from-bivectors>Rotations from Bivectors</a>
below.)</p><h4 id=the-same-duality-in-4d><a class=anchor href=#the-same-duality-in-4d title='Anchor for: The same duality in 4D.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>The same duality in 4D</h4><p>In the spacetime algebra (STA) the duality is between spacelike bivectors
and timelike bivectors:
$$
i e_1e_2 = -e_0e_3
$$
for example. Where here $i=e_0e_1e_2e_3$.</p><p>This is pretty nice, it means the dual of a space rotation is a Lorentz boost.
Make of that what you will.
We might not know this if we had stuck with Gibbs vector algebra or the
quaternions our whole life.</p><p>You ask, &ldquo;Why are these bivectors the rotations?&rdquo;
We&rsquo;ll get to that <a href=#rotations>below.</a>
The &ldquo;looking ahead&rdquo; answer is that the bivectors are the infinitesimal Lie
generators for the rotations, not the full rotation proper.</p><h3 id=the-pseudo-pauli-algebra><a class=anchor href=#the-pseudo-pauli-algebra title='Anchor for: The pseudo-Pauli algebra.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>The pseudo-Pauli algebra</h3><p>The geometric algebra just for the 1-vectors can be completely characterized
in a one-liner:
$$
e_ie_j = e_i\cdot e_j + e_i\wedge e_j = \delta_{ij} + I\epsilon_{ijk}e_k
$$
where $\epsilon_{ijk}$ is the usual permutation symbol,and $I=e_1e_2e_3$ is
the $\mathcal{G}^3$ pseudoscalar, a trivector.</p><p>Readers can verify this is isomorphic to the Pauli algebra in quantum
mechanics, which is a matrix representation, defining,
$$
\hat{\sigma_1} = \left(
\begin{array}{cc}
0 & 1 \\
1 & 0
\end{array}\right),\quad
\hat{\sigma_2} = \left(
\begin{array}{cc}
0 & -i \\
i & 0
\end{array}\right),\quad
\hat{\sigma_3} = \left(
\begin{array}{cc}
1 & 0 \\
0 & -1
\end{array}\right)
$$
which satisfy,
$$
\hat{\sigma_i} \hat{\sigma_j} = \delta_{ij} \mathbb{1} + i\epsilon_{ijk}\hat{\sigma_k}
$$</p><p><strong>Incidentally:</strong> in the $(+\!-\! - -)$ metric signature I think that
$\hat{\sigma}$ are as above, but if we go to the general relativists
preferred metric $(-\!+\!++)$ then I think some of the $\pm$ signs across
the matrix diagonals swap around.
I will have to come back and check this.</p><p>But why should the spacetime metric matter here? We are not using
an $\vec{e}_0$.</p><p>This relates to the reason I call the $\mathcal{G}^3$ relations the
&ldquo;pseudo-Pauli algebra&rdquo; which is because we will later find that the
Pauli algebra proper &mdash; the one mapping onto Pauli spinors &mdash;
is better taken as the algebra of <em>relative vectors</em> in the STA
(spacetime algebra).</p><p>We&rsquo;ll do that in a next chapter, but just note for now what I mean by
a <strong>relative vector</strong> &mdash; which means a bivector that has a time component.
Thus, <em>define</em>
$$
\boldsymbol{\sigma}_i = e_0 e_i
$$
which is a bivector in the STA, but gets treated as a spatial basis 1-vector
in the Pauli algebra.</p><p>A bit confusing? Yes.
I did not invent this terminology.
If it were all up to me I&rsquo;d just straight up say the &ldquo;Pauli algebra&rdquo; is
a <em>bivector</em> algebra in the spacetime setting, namely an even subalgebra
of $\mathcal{G}^{1,3}$.</p><p>The justification for the terminology &ldquo;relative vector&rdquo; comes from the
idea that in Pauli mechanics we are non-relativistic, so time is just a
passive background, and the bivectors $e_0e_i$ (or $e_ie_0$ for opposite
metric) really are just like 3-space objects,
since there is a well defined global time direction.
Whereas for a rotationally symmetric 4-geon, or for an orbiting particle,
the space part $e_i$ is relative, it designates a preferred spin orientation,
or angular momentum axial vector, relative to the particle&rsquo;s moving frame.</p><p>The latter is only an issue in special relativity and GR when a
global time direction is not defined.</p><p>Nevertheless, it seems sort of &ldquo;deep&rdquo; to me that we are implicitly using a
spacetime perspective even in such a non-relativistic QM.</p><h2 id=bivector-algebra><a class=anchor href=#bivector-algebra title='Anchor for: Bivector algebra.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Bivector algebra</h2><p>In $\mathcal{G}^3$ the bivector algebra has a handedness.
We take the cyclic permutations from the set $\{1,2,3\}$.
This gives a right-handed structure.
$$ \begin{array}{ll}
B_1 \!\!\!&= e_2e_3 = Ie_1 \\
B_2 \!\!\!&= e_3e_1 = Ie_2 \\
B_3 \!\!\!&= e_1e_2 = Ie_3
\end{array}$$</p><p>By contrast, Hamilton&rsquo;s quaternions have an induced <em>left-handed</em> structure,
which we could get from $\mathcal{G}^3$ by putting $B_2 = e_1e_3 = -e_3e_1$.</p><p>This is why the quaternions are not suitable for generalizing rotations,
and why the search for a natural algebra for 4D spacetime rotations was futile
(they were looking to Octonions, which are the incorrect$^\ast$ generalization,
the correct generalization is the spacetime algebra $R^{1,3}$ or $R^{3,1}$
depending on signature convention).</p><p>$^\ast$ I suppose &ldquo;incorrect&rdquo; but I do not really know, I guess it is possible
to do spacetime rotations with Octonions, but it&rsquo;ll be awfully messy.</p><h3 id=the-complex-structure-in-mathcalg3><a class=anchor href=#the-complex-structure-in-mathcalg3 title='Anchor for: The &ldquo;complex&rdquo; structure in $\mathcal{G}^3$&mldr;.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>The &ldquo;complex&rdquo; structure in $\mathcal{G}^3$&mldr;</h3><p>As before with $\mathcal{G}^2$, in $\mathcal{G}^3$ we can find a closed even
subalgebra $\mathcal{G}^+_3$.
This will have scalars and bivectors but <em>also</em> the pseudoscalar $I$.</p><h4 id=-is-related-to-the-pauli-algebra><a class=anchor href=#-is-related-to-the-pauli-algebra title='Anchor for: &mldr; is related to the Pauli algebra.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>&mldr; is related to the Pauli algebra</h4><p>This even subalgebra is almost the Pauli algebra, which most people think of
as an inherently matrix algebra over $\mathbb{C}$.
Once we have tackled the rudimentary 3D rotations we will
exhibit the proper Pauli algebra over the reals $\mathbb{R}$,
for which a time-like basis vector $e_0$ is needed.
That&rsquo;ll be in the <a href=../005_spacetime_algebra>next chapter.</a></p><p>The reason we cannot quite get the Pauli algebra proper from 3-space is
because we will lack a pseudoscalar that anti-commutes with 1-vectors.
By going up to 4D spacetime, we get a proper pseudoscalar,
and then reduce back to 3-space spin algebra by restricting to the simplest
non-trivial even subalgebra (scalars + bivectors).
This means just ignoring Lorentz boosts (space+time rotations) among
our symmetries.</p><h2 id=reflections-and-rotations><a class=anchor href=#reflections-and-rotations title='Anchor for: Reflections and Rotations.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Reflections and Rotations</h2><p>Now we are getting closer to the gold.
The way we rotate multivectors is truly special and
beautiful, and is the foundation for most of quantum mechanics over the
real numbers instead of the complex numbers.</p><h3 id=reflections><a class=anchor href=#reflections title='Anchor for: Reflections.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Reflections</h3><p>Reflections are simplicity personified in GA.
Suppose we wish to reflect a vector $a$ about the plane with unit normal
$\vec{n}$. Then we perform the transformation via:
$$ a \longrightarrow a^\prime =-nan $$</p><p>That&rsquo;s it!</p><p>You can prove for yourself this is true in all cases in any dimension D,
either by using coordinates, or for 2D in a diagram, or using more
conceptual reasoning.
I like the conceptual.
It goes like this: the geometric product $an$ has two parts,
$$ an = a\cdot n + a\wedge n $$
The first inner product is a projection of $a$, since $\vec{n}$ is unit the
length of this scalar projection is $|a|\cos\theta$ were $\theta$ is the
angle between $a$ and $\vec{n}$.</p><p>The second part is a bivector in the plane of $a$ & $n$, it has magnitude
$|a|\sin\theta$.</p><p>If we now left multiply the first term, by $-n$ the first scalar term becomes
a vector length $|a|\cos\theta$ but now directed along $-\vec{n}$, that is,
normal to the plane of reflection but on &ldquo;the other side&rdquo;.
You can easily see (in your mind) this is the component of the reflected $a$ we
seek that is perpendicular to the reflection plane.
To complete the reflection we must add to this the component parallel to the
plane.</p><p>The product $-n (a\wedge n)$ does just this!
To see how, recall $(a\wedge n)$ was the bivector in the plane of $a$ and $n$.
So if we outer product this bivector with $\vec{n}$ we get zero, since
$\vec{n}$ is coplanar with this bivector.
So there is only a non-zero inner product term here,
$$ -n \cdot(a\wedge n) $$
For this we only need to look at the component &ldquo;$a_\parallel$&rdquo; of $a$
parallel to the plane (perpendicular to $\vec{n}$) since the other
vector component $a_\perp$ gives a vanishing term when wedged with
$\vec{n}$ since <em>it</em> is parallel with $\vec{n}$. So,
$$ -n \cdot(a\wedge n) = -n \cdot a_\parallel \wedge n$$</p><p>But when a unit vector is &ldquo;dotted&rdquo; into any wedge product involving itself,
like this, it is going to purely project down a dimension up to a $\pm$ sign,
and do nothing else, so all we end up with is,
$$ -n \cdot(a\wedge n) = n\cdot n \wedge a_\parallel = a_\parallel$$
That is precisely the component of the reflection of $a$ parallel to the
reflection plane.</p><p>This completes the proof.</p><p>(Obviously in a video lesson I will be drawing this live.
The videos will come later, maybe in 2023.)</p><p>If you must have visuals instead of exercising your mind, the diagram below
gives the gist of it.</p><img src=../../images/reflection_GA.png alt="reflection in GA" style=width:569px;height:385x><h4 id=a-much-better-proof><a class=anchor href=#a-much-better-proof title='Anchor for: A much better proof.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>A much better proof</h4><p>OK, I made you read all that, but to illustrate there are often &ldquo;too many ways&rdquo;
to go about proving results in GA.
In fact I&rsquo;ve found this very frustrating myself when learning and continuing
to learn GA.
It means sometimes I have no clue where to start on proving some result,
like a <em>discerning</em> kid in a candy shop,
and as a consequence I tend to just end up reading the original proofs,
which probably badly curtails some good brain wiring.</p><p>However, there is a consolation for the physicist, since we&rsquo;re not really in
the business of coming up with mathematical theorem&ndash;proof structures,
we will take a proof when we can get it.
The consolation is that if we follow the prior proofs given by our ancestors,
we get to make more new discoveries faster.
I liken this to computer programming: every n00bie programmer gets it drilled
into their skull to &ldquo;re-use the code.&rdquo;
You never want to reinvent the wheel, but you also &ldquo;must study the code&rdquo; and
<strong><em>never blindly cut & paste</em></strong> (for if you do some Zen master of the
Dark Church of GNU will likely wipe your brain, and your code).</p><p>So the better proof?</p><p>Look back at the diagram.
Note that $a_\parallel$ is perpendicular to $\vec{n}$, and is thus the
component unchanged by the reflection.
Also, $a_\perp$ is the only bit reflected, and it goes to $-a_\perp$.
Hence,
$$ a^\prime = a_\parallel - a_\perp $$
but also,
$$ -n a_\parallel n = n n a_\parallel = n^2 a_\parallel = a_\parallel$$
Slick huh? Howso? Because given $n$ is orthogonal to $a_\parallel$ they
must anti-commute, just like a pair of frame basis vectors.</p><p>(If it helps, imagine making the frame $e_1=a/|a|$ and $e_2=\vec{n}$.)</p><p>The other bit of the reflection is clearly $-a_\perp$, so we immediately see,
$$
\begin{array}{rl}
a^\prime \!\!\!&= a_\parallel - a_\perp \\
&= -n a_\parallel n - n a_\perp n\\
&= -n (a_\parallel + a_\perp ) n = -n a n\\
\end{array}
$$
in the second line we again use orthogonality, specifically
$\vec{n}\parallel a_\perp$ so their geometric product is a scalar product
and hence commutes.
In the last line we&rsquo;ve just used distributivity.</p><p>This completes the proof.</p><p>Oh yes! <em>Distributivity</em> was the crucial property I forgot to discuss in the
foundations above. Please go and add this in now!</p><p><strong>Exercise 4.</strong> Establish the geometric product distributes over addition.</p><h4 id=remarkably-these-reflections-work-for-any-simple-multivector><a class=anchor href=#remarkably-these-reflections-work-for-any-simple-multivector title='Anchor for: Remarkably: these reflections work for any simple multivector.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Remarkably: these reflections work for any simple multivector</h4><p>This means any <em>geometric</em> object can be reflected by the exact same operation
as we used for the vectors! Remarkable!</p><p>We leave the proof for you for optional homework.
The result is for homogeneous multivectors only,
since they are what could be called &ldquo;geometric objects.&rdquo;
In general mixed grade multivectors will rotate by different rules,
such as we will find below for the <strong>rotors</strong> which are even grade but
mixed grade, so should not be called &ldquo;objects&rdquo;.
(You only need to worry about the basis $n$-blades then.)</p><p><strong>Exercise 5.</strong> Prove or convince yourself any rotation anywhere can
be generated by composing two reflections, and in the manner to be
indicated next.</p><h3 id=rotations><a class=anchor href=#rotations title='Anchor for: Rotations.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Rotations</h3><p>Associated with the bivectors for either $\mathcal{G}^3$ or STA
($=\mathcal{G}^{1,3}$) are oriented parallelograms, as previously mentioned.
They define rotations by identifying the plane of rotation, which means all
we need is an angle.
This massively simplifies computations in $\mathcal{GA}$ compared to
clunky matrix algebra or quaternion algebra.</p><p>We do so by exploiting the well-known fact that
<strong><em>every rotation can be generated by composing two reflections, and for any space dimension $D$</em></strong> and by God$^\ast$ <strong><em>for any object of any shape or grade</em></strong>.</p><p>$^\ast$ Take this as shorthand for &lsquo;platonic&rsquo; &mdash; true in every possible world.</p><p>Now the wizardly thing is we can now rotate a vector
$a\longrightarrow a^\prime$ using <strong><em>almost</em></strong> any old pair of unit vectors
$\vec{n}$ and $\vec{m}$ provided simply that,</p><blockquote><p>$\vec{n}$ and $\vec{m}$ lie in the plane of rotation, and the angle
between them is half the angle of the desired rotation.</p></blockquote><p>With this stipulated (supposing we can find two such vectors) we rotate
$a$ simply by a geometric product formed from the two reflections,
$$ a\longrightarrow a^\prime = -m(-nan)m = mn a nm. $$
Boom!</p><p>This should be spooky, since we&rsquo;ve said &ldquo;half angle.&rdquo; Remind you of fermions?
We&rsquo;ll get to this.</p><p><strong>Comment:</strong> Did you catch the fact the bivector $n\wedge m$ captures the
sense of the rotation too?
The angle of rotation is &ldquo;from $\vec{n}$ towards $\vec{m}$&rdquo;.
If that happened to be anti-clockwise from the perspective of an ant wandering
around on the $n\wedge m$ plane, then a rotation performed by the bivector
$m\wedge n$ would look clockwise.</p><p>We now see a simplification, we define a new object called a <strong>rotor</strong> for
the rotation,
$$ R = mn$$
and what we call it&rsquo;s <strong>reverse</strong>,
$$ \tilde{R} = nm $$
then a rotation is performed by the geometric product,
$$
a^\prime = R a \tilde{R}
$$
<strong>Definition:</strong> The <strong>reverse</strong> of <em>any</em> multivector is computed by
simply reversing the order of products of all 1-vectors in the
geometric products. Full reverse, so
$$
A=abcd \quad\Rightarrow\quad \tilde{A}=dcba.
$$</p><p>Because this is a frame-free way to rotate vectors, it is the way to rotate
all objects in the entire geometric algebra, so for <em>any</em> multivector $A$,
$$ A^\prime = RA\tilde{R} $$</p><p>The &ldquo;small price&rdquo; to pay for avoiding a matrix is that the rotation is a
double-sided operation. But hey! Note that&rsquo;s no different to bra-ket
amplitudes in quantum mechanics:
$$ \langle\psi| A | \psi\rangle $$
whaddya know!
Looks like rotation to me. $R\cong \langle\psi|$, and
$\tilde{R}\cong |\psi\rangle$ perhaps?
In fact, this is almost exactly (up to a dilation) what Dirac&rsquo;s expectation
value bra-ket is doing.
But that&rsquo;s a few chapters away.
The unbearable mystery of it all.</p><h3 id=Rotations-from-bivectors><a class=anchor href=#Rotations-from-bivectors title='Anchor for: Rotation in terms of the bivector and the angle.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Rotation in terms of the bivector and the angle</h3><p>The rotor $R$ is typically a sum of a scalar plus bivector
(since it&rsquo;s a geometric product of two 1-vectors).
So it encodes the angle and the plane together.
But we can tease these apart to describe a rotation in another way.</p><h2 id=rotors-transform-single-sided-under-some-other-rotation><a class=anchor href=#rotors-transform-single-sided-under-some-other-rotation title='Anchor for: Rotors transform single-sided under some other rotation.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Rotors transform single-sided under some other rotation</h2><p>Here is the pay cheque for this chapter.
We get now the first glimpse that Dirac and Pauli spinors are really
just single-sides of &ldquo;an instruction to rotate&rdquo; and that this explains why
they behave algebraically like &ldquo;fermions&rdquo;.</p><p>This will not immediately explain Fermi&ndash;Dirac statistics, because
(a) we have no concept of an elementary particle yet, and
(b) Fermi&ndash;Dirac and Bose&ndash;Einstein statistics are all about interacting or
coupled 4-geons, or at least <em>pairs</em> of indistinguishable particles.
How we represent pairing of particles is a problem for a later chapter.</p><p>Before all that to come much later, let&rsquo;s just get the idea of how the
rotation angle $\theta$ is expressed.</p><p>First up, $\theta$ is twice the angle between $\vec{n}$ and $\vec{m}$.</p><p>We could figure this out similarly to the way we got the reflections.
First, we only need to worry about the component of $\vec{a}$ that lies in
the plane defined by the bivector $n\wedge m$
(since the perpendicular component is unchanged by the rotation
(clearly unchanged by both reflections).</p><p>The rotation of just this parallel component of $\vec{a}$ (the component
in the plane of rotation) is illustrated below.</p><img src=../../images/rotation_GA.png alt="rotors rotate" style=width:600px;height:438x><p>OK, admittedly this is a bit unclear how the rotation from $a$
to $a^{\prime\prime}$ is in fact by $\theta$.
But I will assume you are convinced.</p><p>Then we&rsquo;ve got,
$$ a^{\prime\prime} = a_\perp - mn a_\perp nm $$
the advantage of this expression being we can easily compute the second term.
Bah, bah, blah. But we want to get the rotor. How?</p><p>Well, since $\vec{n}$ and $\vec{m}$ are unit vectors with spread angle
$\theta/2$ from our prior work we immediately have,
$$
\begin{array}{rl}
R = mn \!\!\!&= m\cdot n + m\wedge n \\
&= m\cdot n -n\wedge m \\
&= \cos(\theta/2) - B \sin(\theta/2)
\end{array}
$$
and similarly,
$$
\begin{array}{rl}
\tilde{R} = nm \!\!\!&= n\cdot m + n\wedge m \\
\!\!\!&= m\cdot n + n \wedge m \\
&= \cos(\theta/2) + B \sin(\theta/2)
\end{array}
$$
where we defined the unit bivector for the rotation $B=n\wedge m$.
Hence the reverse of sign on the $\sin \theta$ for $R$ but not
for $\tilde{R}$.</p><p>Now if we are given a unit bivector and angle we can compose the
desired rotation via rotors,
$$
a^{\prime\prime} = \bigl(\cos(\theta/2) - B\sin(\theta/2)\bigr) a \bigl(\cos(\theta/2) + B\sin(\theta/2)\bigr)
$$
which looks like a marginal improvement on matrix rotation, but it&rsquo;s a
far superior improvement, since this result holds in any space dimension,
imagine writing the 100$\times$100 matrix for this!
Changing space dimensions changes the whole lot,
whereas in the $\mathcal{GA}$ we do not need to alter a thing,
this formula is universal.
Truly universal.
It will even hold for spacetime rotations, aka. Lorentz boosts.</p><p>But we can clean it up a little.
Note from earlier the bivector $B$ defines a complex structure,
$$ z = x + B y $$
well then, what did we learn in high school? Euler formula anyone?
So we get the beautiful formula for all rotations,
$$
a^{\prime\prime} = e^{-B\theta/2} a e^{B\theta/2}.
$$</p><p><strong>Note:</strong> also note that all unit bivectors square to $-1$,
$$
B^2 = -1,\qquad\text{if}\quad |B|=1.
$$
and the rotors have a nice property you can use as a sanity check,
$$
R\tilde{R} = 1
$$
so the reverse of a rotor is it&rsquo;s inverse.</p><p>Why? Well, because apart from the scalar angle $\theta$ the rotation is
specified by a unit bivector.
The &ldquo;encoding&rdquo; is that the bivector part in the rotor exponent &ldquo;just rotates&rdquo;
and there is nothing out front of the exponential, so there is no dilation.</p><p>This also makes it manifestly clear the rotor rule is indeed a rotation.
We did not fully check that it is before!
I showed the picture, and gave some of the clues.
But now we know for sure what we&rsquo;ve been doing is rotations, since
the rotation is characterised by it&rsquo;s symmetries:</p><blockquote><p>Rotations are the unique smooth linear transform globally preserving
(i) lengths and (ii) angles between vectors, and they preserve the metric.
(Reflections are not smooth.)</p></blockquote><p>This is pretty much the same as you learned in school in the 2D case,
where unit complex numbers on the circle can be used to rotate
complex numbers,
$$
z\longrightarrow z^\prime = z e^{i\theta}
$$
only with the rotors in a $\mathcal{GA}$ we have far more power and generality,
indeed, we have <em>universality</em>.</p><p>I will note some software below you can write this formula in and see it
work, numerically and symbolically.</p><p>Before we head to spacetime algebra though, I want to note how rotors
themselves transform under a rotation.</p><h2 id=rotors-transform-single-sided><a class=anchor href=#rotors-transform-single-sided title='Anchor for: Rotors transform single-sided.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Rotors transform single-sided</h2><p>Thing is, if we rotate a rotor, say $R$, by some definite rotation rotor
$R_1$, we get,
$$
R^\prime = R_1 R \tilde{R}_1
$$
which will no longer be a rotor for rotation by the same angle as $R$.
That seems a shame. But nothing is shameful in mathematics except obscurity
(not even human error is shameful, unless it is deliberate and malicious
&mdash; plenty of good books to read on mathematical paradoxes resulting from
simple-minded errors).</p><p>Thing is, on the other hand, if we truly want to compose rotations to form
a proper <strong><em>rotor algebra</em></strong> which we truly do, we damn well need the
composition of two rotations to be another rotor.
Thus, we really want to look at the composite rotor $R_1R_2$ to see if it
does the job. Otherwise it&rsquo;d be shameful-ish.</p><p>Let&rsquo;s see. Begin by just defining the, or a, composite rotor:
$$R_{12}=R_2R_1$$
(We are not sure it&rsquo;s the right one yet.)</p><p>We are going to guess, but need to prove, this will perform the composite of
the two rotations, otherwise we will not have a good Lie algebra in
$\mathcal{GA}$ for $\text{SO}(n)$.</p><p>Since rotations do not always commute (they do in 2D, but assume you learned
that for at least 3D, or just try it now with a coloured cube or tea cup) we
write the order correctly, so that from the implied reflections we are going
to be rotating by $\theta_1$ first and then by $\theta_2$.</p><p>Next, write this out:
$$
\begin{array}{rl}
R_2R_1 a \tilde{R_1}\tilde{R_2} \!\!\!&= R_2R_1 a \tilde{R_1}\tilde{R_2} \\
&= R_{2} \biggl[ \bigl(\cos\theta_1/2 - B_1 \sin\theta_1/2\bigr) a \bigl(\cos\theta_1/2 + B_1 \sin\theta_1/2\bigr)\biggr] \tilde{R_2}
\end{array}
$$
and I won&rsquo;t expand the whole lot here, it gets a bit long-winded, but is straight forward, you just expand $R_2(\theta_2,B_2)$ as we did $R_1$.
But now it&rsquo;s better to use Euler&rsquo;s exponential notation,
because then we can manipulate the exponential arguments,
and note the scalar angles commute with the bivectors $B$, so:
$$
\begin{array}{rl}
\tilde{R_{12}} a R_{12} \!\!\!&= e^{-B_2\theta_2/2}e^{-B_1\theta_1/2}\, a\, e^{B_2\theta_2/2}e^{B_2\theta_2/2} \\
&= e^{-B_2B_1(\theta_2+B_1\theta_1)/2}\, a\, e^{B_2B_1(\theta_2+\theta_2)/2} \\
&= R_{12} a \tilde{R_{12}}
\end{array}
$$
which looks correct, although is that last line obvious?
No, it is not.
What is the reverse of $R_{12}$?
It&rsquo;s obtained by reversing the vectors in geometric products,
but,
$$R_{12}= R_2R_1 = (n_2m_2)(n_1m_1) $$
and so,
$$
\begin{array}{rl}
\tilde{R}_{12} \!\!\!&= m_1n_1m_2n_2 \\
&= \tilde{R}_1\tilde{R}_2 \\
&= e^{B_1\theta_1/2}e^{B_2\theta_1)/2} = e^{B_1B_2(\theta_1+\theta_2)/2}
\end{array}
$$
all good!</p><p>Well, that wasn&rsquo;t too bad. But this just proves the composite rotor was
indeed our guess $R_{12}=R_2R_1$.
We haven&rsquo;t quite solved what happens to a rotor.</p><p>But you can now work it out logically.</p><h3 id=take-a-random-rotor-r><a class=anchor href=#take-a-random-rotor-r title='Anchor for: Take a random rotor $R$.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Take a random rotor $R$</h3><p>What we wanna know is what happens to $R$ when we rotate by some other
rotation operation, say $R_1$.
What becomes of $R$ under,
$$
\mathcal{R}_{(\theta_1,B_1)}(Ra\tilde{R}) = R_1 (R a \tilde{R}) \tilde{R_1}
$$
In other words, what changes about $R$ if we&rsquo;ve, maybe accidentally,
rotated by $(\theta_1,B_1)$?</p><p>Well, thanks to the work above on composite rotations we have the answer.
It&rsquo;s gotta be the composite rotor,
$$ R \longrightarrow R^\prime = R_1 R $$
Wow! Or whoa! (never sure which to type.)</p><p>So the random rotor does not get acted on by rotations in the double-sided
manner of the vectors or multivectors.
They get acted on by left multiplication! Damn!</p><p>That sounds an awful lot like spinors under rotation and boosts, doesn&rsquo;t it?</p><p>Yeah. Rotors <em>are</em> types of spinor.</p><p>Here&rsquo;s the thing. We did not need some
<a href=https://en.wikipedia.org/wiki/Anti-twister_mechanism target=_blank>Dirac belt trick</a>
to get this, (which in any case only applies to 3D).
(Although some 4-geons may turn out to be tethered particles,
where the Dirac belt trick applies, in fact if they are connected by wormholes
they surely are tethered in some way.)</p><p>Let&rsquo;s ask then, what rotation angle for $R_1$ (still fixed arbitrary $B_1$)
gives back our original random rotor $R$? Is it $\theta=2\pi$.</p><p>Let&rsquo;s consider rotating a vector $\vec{v}$ once around a closed loop, any loop.
Then,
$$R_1 = e^{-B2\pi/2} = e^{-B\pi}$$
But now apply this to our random rotor $R$, it must go to,
$$
R^\prime = R_1 R = e^{-B\pi} R = \bigl(\cos\pi - B\sin\pi\bigr) R = -R
$$
Holy smoke! Same wow as before.</p><p>A $2\pi$ rotation of a vector gave us a rotor that only flipped.
But a flip is a rotation of a multivector by $\pi$, or $180^\circ$,
so to get back the original rotor we actually need a space angle of
$\theta=4\pi$
rotation from $R_1$ (like a &ldquo;fermion&rdquo;).
While the <em>vector</em> we had will now go around the loop twice (like a &ldquo;boson&rdquo;).</p><p>That&rsquo;s the Dirac belt property for fermions, but here for a rotor $R$.
So we have begun to see how fermions and Fermi&ndash;Dirac statistics (perhaps) are
related to rotational invariance.
But this is classical geometry over the real numbers!</p><p>What&rsquo;s going on? This is pure classical geometry.</p><p>What&rsquo;s going on is the rotor is not a &ldquo;real&rdquo; physical thing, it&rsquo;s
a <strong><em>process</em></strong>. Why would you ever expect a <em>process</em> to behave like
a physical object made of matter? Like a belt? No! A belt is not a process.</p><p>However, the Dirac belt trick <em>is</em> a process. Think about that!</p><p>Is this a hint while electrons and quarks are certainly <em>matter</em>
the wave-functions we use to represent them are not?
(Why yes, that&rsquo;s exactly what I think, not sure about you. I learned it
from Hestenes.)</p><p><strong>Last comment for now on rotors:</strong> I mentioned above we could prove all
simple or homogeneous multivectors get rotated by the same law,
double-sided action of a rotor and it&rsquo;s reverse.
But these are the geometric objects.
This means the mixed grade objects like rotors, our $R$, are not really
&ldquo;geometrically homegeneous,&rdquo; which means (whatever else it may mean)
that they are not &ldquo;physical things&rdquo; that we could build out of lego blocks
or drilling holes in spacetime.</p><p>That might sound like a bit of deep philosophy, but no one could make any
sense of it without this sort of $\mathcal{GA}$ insight.
Yet we have it almost by accident.
But it accords with very old and ancient wisdom that <em>Processes</em> in nature
are different Types to physical <em>Objects</em>.</p><p>Objects being things that exist and Processes being changes in Objects.</p><p>The rogue mathematician in NSW Australia,
<a href=https://www.youtube.com/@njwildberger target=_blank>Norm Wildberger,</a>
has this view that irrational numbers and infinities are not numbers, since,
he thinks, numbers should be sort of &ldquo;real&rdquo; or &ldquo;mechanical&rdquo; and &ldquo;computable&rdquo;
whereas irrationals can never be written down or computed fully,
but we do know processes (algorithms) that if run forever would in some
sense &ldquo;print them out.&rdquo;
(Or you could use a non-relativistic Turing machine that speeds up twice every
$1/2^n$ seconds, to get the whole infinite job done in 2 seconds.)</p><p>This is only a bit of thinking fun, I do not take it too seriously,
since I&rsquo;m a platonist.
So to me, all numbers and geometrical objects are things conscious minds can,
or <em>might</em> in some flashes of thought, mentally access (the <em>qualia</em>)
anywhere there is consciousness, independently of a particular physical,
or other type of, world.
Not that our minds are perfectly able to access perfect qualia, but we can get
glimpses of the platonic reals.</p><p>I like to say, no one understands or even glimpses the shape of the
Monster Group, but everyone knows what a pure platonic perfect circle
looks like, but they see it for real only in their mind, since every
possible physical instance of a circle is flawed.</p><h3 id=lie-group-generators><a class=anchor href=#lie-group-generators title='Anchor for: Lie group generators.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Lie group generators</h3><p>Above we very easily discovered the rotations are computed by exponentiating
a bivector. The <strong><em>bivector</em></strong> completely specifies the <strong><em>rotation</em></strong>!</p><p>How come?
Well, above we used the unit bivectors, but we could multiply them by the
scalar half-angles $A=B\theta/2$, they remain bivectors, so all rotations
can be computed from rotors like,
$$ R = e^{A}
$$
A group theorist will come along and tell you that looks like a wonky
Lie group element, only with a strange generator,
since the &ldquo;complex&rdquo; number $i$ is supposed to go upstairs in the exponent.</p><p>The GA theorist says, &ldquo;No, you idiot. The unit bivector $B$ is oriented
and anti-symmetric,
$B^2=-1$, and is isomorphic to the unit imaginary in it&rsquo;s bivector algebra.&rdquo;</p><p>Thus the bivectors <em>are</em> the Lie algebra generators for all rotation groups.</p><h2 id=quick-note-projective-and-conformal-geometry><a class=anchor href=#quick-note-projective-and-conformal-geometry title='Anchor for: Quick Note: Projective and Conformal Geometry.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Quick Note: Projective and Conformal Geometry</h2><p>I do not have place to cover projective or conformal geometry, but these
topics are worth a mention, because in modern stylish theoretical physics
they are recognized as important topics. Projective geometry is also of
enormous computational importance in robotics. Robots &ldquo;see&rdquo; a 2D field,
so like use their &ldquo;brains&rdquo; have to use projective geometry concepts, only
instead of these been wired by natural evolution we will short-cut that
and program them. (Or perhaps we should have some robot communities for
which we wait around for them to evolve vision systems? Because you never
know the collateral benefits!)</p><p>For theoretical physics I&rsquo;m only interested in fundamental theory, but
in both anti-de Sitter and de Sitter spacetimes the global geometry
in an assumed approximately homogenous cosmos benefits immensely from
using conformal symmetry, even if it is an inexact symmetry.</p><p>Geometric STA massively simplifies the algebra and computation aspects
(both!) for Projective and Conformal geometry.</p><p>I&rsquo;ll leave it at that for now as a teaser, but before moving topics let&rsquo;s
not some learning resources for this stuff, and some basic motivations.
The topics, should you choose to search for it, has the acronym
<strong>PGA</strong> (Projective Geometric Algebra)</p><h3 id=motivations><a class=anchor href=#motivations title='Anchor for: Motivations.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Motivations</h3><ul><li>In Projective geometry lines and points are dual, this provides plenty
of simplifications for theorem and proof. One theorem concerning lines
translates to a &ldquo;theorem for free&rdquo; about points.</li><li>In PGA we also get planes, lines, points all &ldquo;for free&rdquo;. Lessening our work
considerably.</li><li>We get all the following using the same types of geometric products:
Reflection, rotation, translation (yes!), joins and meets (intersections).</li></ul><h3 id=resources><a class=anchor href=#resources title='Anchor for: Resources.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Resources</h3><p>A legend in the online GA/STA/PGA community is
<a href=https://www.youtube.com/@sudgylacmoe target=_blank>sudgylacmoe</a>
.</p><ul><li>sudgylacmoe
<a href="https://www.youtube.com/watch?v=0i3ocLhbxJ4&amp;pp=ygULc3VkZ3lsYWNtb2U%3D" target=_blank>“A Swift Introduction to Projective Geometric Algebra”</a>
&mdash; this is a cool vdo with all the manim style.</li><li>sudgylacmoe follow-up <a href="https://www.youtube.com/watch?v=T0b8-NJH79s&amp;pp=ygULc3VkZ3lsYWNtb2U%3D" target=_blank>“Two-Dimensional Lines are Three-Dimensional”</a></li><li>sudgylacmoe <a href="https://www.youtube.com/playlist?list=PLVuwZXwFua-0Ks3rRS4tIkswgUmDLqqRy" target=_blank>From Zero to Geo</a>
whihc is the
<a href="https://www.youtube.com/playlist?list=PLVuwZXwFua-0Ks3rRS4tIkswgUmDLqqRy" target=_blank>full playlist on sudgy&amp;rsquo;s look into linear algebra with GA</a></li></ul><p>Steven de Keninck and Leo Dorst tutorial on PGA, from SIBGRAPH-2021:</p><ul><li><a href=https://www.youtube.com/@bivector target=_blank>Bivector</a>
channel &mdash; <a href="https://www.youtube.com/playlist?list=PLsSPBzvBkYjxrsTOr0KLDilkZaw7UE2Vc" target=_blank>PGA Tutorial SIBGRAPI2021</a></li></ul><p>Another talk by Leo Dorst on linear algebra &ldquo;done right with GA&rdquo;:</p><ul><li><a href="https://www.youtube.com/watch?v=9YR3WK2Rqto" target=_blank>“How GA subsumnes, extends, invigorates Linear Algebra”</a></li></ul><div style=text-align:center>*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*</div><p>Now back to my main content.</p><h2 id=lorentz-rotations><a class=anchor href=#lorentz-rotations title='Anchor for: Lorentz Rotations.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Lorentz Rotations</h2><p><strong>Note:</strong> I might not have had time to switch Minkowski metrics above,
that&rsquo;s a TODO. But from hereon I aim to use the east coats metric (+++-).
This is to follow hints I learned about from Peter Woit and William (Bill)
Pezzaglia &mdash; who point out there is a physically preferred signature in our
universe. It is not significant in classical mechanics, but turns out to be
distinguishing in quantum physics.</p><p>Although, to my mind, it is distinguishing even in
classical mechanics (CM)! The reason we do not see the effect of choice
of Minkowski metric in CM is <strong>(a)</strong> mostly we&rsquo;re doing Newtonian CM, and
<strong>(b)</strong>* even in EM and SR we tend to not exploit the Clifford algebra of
spacetime, and especially not employ the non-commutative geometry. Yes, non-
commutative geometry is classical physics. We have all the tricks of
Lagrangians and Hamiltonians to avoid the non-commutative algebra.</p><p>If we find ways to exploit the non-commutative geometry in CM then we should
(I believe) find areas where the matrix representation makes a difference.
The matrix rep. for the west coats metric spacetime algebra is
$\mathbf{H}(2,2)$, the $2\times 2$ quaternion valued matrices. This is
not isomorphic to the real $4\times 4$ matrix algebra which is the
representation for the east coast metric. If you can find a physical
difference involving these differing representations than you&rsquo;ve found a
potential experimentally testable preferred choice of spacetime metric for
our universe!</p><p>I believe <a href=https://arxiv.org/pdf/gr-qc/9704048 target=_blank>Pezzaglia (here)</a>
recovered metric form invariance though, by pointing
out most authors are not generalizing the Dirac wave mechanics fully, he
identifies a &ldquo;generalized multivector wave equation&rdquo; that <em>does</em> recover
metric form invariance.</p><p>However, I also believe there are further subtleties than can pick out the
east coats signature, and they involve chirality for the electroweak
interactions. But I have not adequately explored this yet to comment any
further. I just use this hint as motivation to redo as much STA as I can
with:
$$
\{\gamma_1, \gamma_2, \gamma_3, \gamma_4\},\quad \gamma_k^2=1,\quad \gamma_4^2 = -1, \quad \gamma_\mu\gamma_\nu = - \gamma_\nu\gamma_\mu.
$$</p><p>By the way, just as a kind of friendly jibe: Hestenes-Lasenby-Doran call
their applied GA of $C\ell_{1,3}$ the &ldquo;spacetime&rdquo; algebra, but that&rsquo;s a
misnomer, if the order is $+$ then $-$ then their&rsquo;s is a timespace
algebra. ;-)</p><h3 id=a-z-boost><a class=anchor href=#a-z-boost title='Anchor for: A $z$ Boost.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>A $z$ Boost</h3><p>The boost is a spacetime rotation. The bivector generator is
$$
B=\alpha e_3e_4
$$
where $\alpha = tanh^{-1}(\beta)$ is the <em>rapidity</em>. As usual $\beta$ is,
$$
\beta = v/c
$$
and the SR $\gamma$ factor is,
$$
\gamma = (1-\beta^2)^{-1/2}
$$
To produce the boost simply form the rotor for it,
$$
R = e^{B/2}
$$
To compute the transformations for the cartesian base vectors, simply
rotate the base vectors as you would for any GA rotation:
$$
e_x^\prime = R e_x \tilde{R}
$$
this will be $e_x^\prime = e_x$ of course. The only coordinates altered
for a $z$ boost are $(z,t)$,
$$
\begin{align*}
e_x^\prime = R e_x \tilde{R} \\
e_4^\prime = R e_4 \tilde{R} \\
\end{align*}
$$
Since I don&rsquo;t trust myself on paper I use the Python package
<strong><a href=https://galgebra.readthedocs.io/en/latest/getting-started.html target=_blank>galgebra</a>
</strong>.</p><div class=highlight><pre aria-label="Box containing code sample." tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sympy</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>galgebra.ga</span> <span class=kn>import</span> <span class=n>Ga</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>txyz</span> <span class=o>=</span> <span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=p>)</span> <span class=o>=</span> <span class=n>sympy</span><span class=o>.</span><span class=n>symbols</span><span class=p>(</span><span class=s1>&#39;t x y z&#39;</span><span class=p>,</span> <span class=n>real</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>o4d</span> <span class=o>=</span> <span class=n>Ga</span><span class=p>(</span><span class=s1>&#39;ex ey ez et&#39;</span><span class=p>,</span> <span class=n>g</span><span class=o>=</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=n>coords</span><span class=o>=</span><span class=n>txyz</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>e1</span><span class=p>,</span> <span class=n>e2</span><span class=p>,</span> <span class=n>e3</span><span class=p>,</span> <span class=n>e4</span> <span class=o>=</span> <span class=n>o4d</span><span class=o>.</span><span class=n>mv</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>Lorentz Boosts
</span></span></span><span class=line><span class=cl><span class=s1>---------------
</span></span></span><span class=line><span class=cl><span class=s1>These are STA rotations with a basis of bivectors 
</span></span></span><span class=line><span class=cl><span class=s1>   ek*e4 = sk
</span></span></span><span class=line><span class=cl><span class=s1>and &#34;rapidity&#34; alpha/2
</span></span></span><span class=line><span class=cl><span class=s1>   tanh(alpha) = beta = |v|/c.
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=n>sec</span> <span class=o>=</span> <span class=s1>&#39;Ex. Lorentz boost by beta=0.9 in the zt plane&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;</span><span class=se>\n</span><span class=si>{</span><span class=n>sec</span><span class=si>}</span><span class=se>\n</span><span class=si>{</span><span class=s2>&#34;-&#34;</span><span class=o>*</span><span class=nb>len</span><span class=p>(</span><span class=n>sec</span><span class=p>)</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>beta</span> <span class=o>=</span> <span class=mf>0.9</span>
</span></span><span class=line><span class=cl><span class=n>alpha</span> <span class=o>=</span> <span class=n>atanh</span><span class=p>(</span><span class=n>beta</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>gamm</span> <span class=o>=</span> <span class=mf>1.</span> <span class=o>/</span> <span class=n>sqrt</span><span class=p>(</span><span class=mf>1.0</span> <span class=o>-</span> <span class=n>beta</span><span class=o>**</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>B</span> <span class=o>=</span> <span class=n>e3</span><span class=o>*</span><span class=n>e4</span> <span class=o>*</span> <span class=n>alpha</span> <span class=o>/</span> <span class=mf>2.0</span>
</span></span><span class=line><span class=cl><span class=n>R</span> <span class=o>=</span> <span class=p>(</span><span class=n>B</span><span class=p>)</span><span class=o>.</span><span class=n>exp</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>xb</span> <span class=o>=</span> <span class=n>R</span> <span class=o>*</span> <span class=n>e1</span> <span class=o>*</span> <span class=n>R</span><span class=o>.</span><span class=n>rev</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>yb</span> <span class=o>=</span> <span class=n>R</span> <span class=o>*</span> <span class=n>e2</span> <span class=o>*</span> <span class=n>R</span><span class=o>.</span><span class=n>rev</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>zb</span> <span class=o>=</span> <span class=n>R</span> <span class=o>*</span> <span class=n>e3</span> <span class=o>*</span> <span class=n>R</span><span class=o>.</span><span class=n>rev</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>tb</span> <span class=o>=</span> <span class=n>R</span> <span class=o>*</span> <span class=n>e4</span> <span class=o>*</span> <span class=n>R</span><span class=o>.</span><span class=n>rev</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39; Check: 
</span></span></span><span class=line><span class=cl><span class=s1>xp = x, yp = y,
</span></span></span><span class=line><span class=cl><span class=s1>zp = gamm * (z - beta*t)
</span></span></span><span class=line><span class=cl><span class=s1>tp = gamm * (t - beta*z)
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Result:</span><span class=se>\n</span><span class=si>{</span><span class=n>xb</span> <span class=si>= }</span><span class=s2>,</span><span class=se>\n</span><span class=si>{</span><span class=n>yb</span> <span class=si>= }</span><span class=se>\n</span><span class=si>{</span><span class=n>zb</span> <span class=si>= }</span><span class=s2>,</span><span class=se>\n</span><span class=si>{</span><span class=n>tb</span> <span class=si>= }</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>Note:
</span></span></span><span class=line><span class=cl><span class=s1>The raw == comaprison doesn&#39;t work, suffers 
</span></span></span><span class=line><span class=cl><span class=s1>from fp round off.
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Is zb == </span><span class=si>{</span><span class=n>gamm</span> <span class=o>*</span> <span class=p>(</span><span class=n>e3</span> <span class=o>-</span> <span class=n>beta</span><span class=o>*</span><span class=n>e4</span><span class=p>)</span><span class=si>}</span><span class=s2>?, </span><span class=si>{</span><span class=p>(</span><span class=n>gamm</span> <span class=o>*</span> <span class=p>(</span><span class=n>e4</span> <span class=o>-</span> <span class=n>beta</span><span class=o>*</span><span class=n>e3</span><span class=p>)</span> <span class=o>-</span> <span class=n>tb</span><span class=p>)</span><span class=o>.</span><span class=n>norm</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Is tb == </span><span class=si>{</span><span class=n>gamm</span> <span class=o>*</span> <span class=p>(</span><span class=n>e4</span> <span class=o>-</span> <span class=n>beta</span><span class=o>*</span><span class=n>e3</span><span class=p>)</span><span class=si>}</span><span class=s2>?, </span><span class=si>{</span><span class=p>(</span><span class=n>tb</span> <span class=o>-</span> <span class=n>gamm</span> <span class=o>*</span> <span class=p>(</span><span class=n>e4</span> <span class=o>-</span> <span class=n>beta</span><span class=o>*</span><span class=n>e3</span><span class=p>))</span><span class=o>.</span><span class=n>norm</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=more-to-come-><a class=anchor href=#more-to-come- title='Anchor for: More to Come &mldr;.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>More to Come &mldr;</h2><p>Just to keep you from forgetting about T4GU, there is a lot more juicy stuff I
have to soon write-up, including showing you how fermions and
Fermi&ndash;Dirac statistics are associated with rotational symmetry invariance
(not just &ldquo;spin-1/2&rdquo;) and how entanglement gives us both,</p><ul><li>the Pauli Exclusion Principle (anti-symmetric wave function upon parity inversion) and</li><li>interference effects.</li></ul><p>Also, the geometric algebra gives a simpler relationship between the Pauli exclusion
principle and the field theory version (the latter being anti-commuting commutation
relations, which are a bit baroque).</p><p>Eventually I hope to upload some software for solving the Dirac equation.</p><ul><li>Numerical simulations of Dirac spinors moving under a magnetic field shock, which dynamically shows how Pauli repulsion works.</li><li>Similar numerical simulations showing how Stern&ndash;Gerlach &ldquo;splitting&rdquo; is a polarization effect, not a &ldquo;discretized spin magnetic moment&rdquo; effect.</li></ul><p>The really juicy delicious thing is that the anti-commuting relations are not
really for &ldquo;spin-1/2&rdquo; since photons and other bosons can also be spin&ndash;coupled,
so can form composite &ldquo;fermionic&rdquo; states, that is, states that are coupled and which thus have Fermi&ndash;Dirac statistics.</p><p>That&rsquo;s what happens to photons in the Two-Slit experiment.
They get coupled.
No one thinks of this as &ldquo;Fermi&ndash;Dirac statistics&rdquo; but it really is,
except now we will be able to understand this is really a result of spin&ndash;coupling,
otherwise known in gauge&ndash;gravity theory as entanglement,
otherwise known as ER=EPR wormhole topology.</p><p>Did I give too much away too early?</p><p>Thus, one goal of these theory pages is to eventually show why the
Pauli Exclusion Principle is more about rotation invariance of singlet states
and spin&ndash;coupling, it&rsquo;s not just about &ldquo;spin-1/2 fermions&rdquo;.</p><h2 id=software><a class=anchor href=#software title='Anchor for: Software.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Software</h2><p>You can check some of the formulas heuristically (for single instance cases) using geometric algebra packages for Maxima or Python, there is also a C++ library, probably others.</p><h3 id=python-galgebra><a class=anchor href=#python-galgebra title='Anchor for: Python galgebra.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Python galgebra</h3><p>By far the easiest I found to use has some symbolics too,
it was the python PIP package <code>galgebra</code>:</p><div class=highlight><pre aria-label="Box containing code sample." tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pip3 install galgebra
</span></span></code></pre></div><p>Documentation can be found
<a href=https://galgebra.readthedocs.io/en/latest/tutorials/algebra.html target=_blank>here: “Introduction to using GAlgebra”</a>
.
This allows you to define a frame using any metric signature, then compute
with it. I found it <em>extremely</em> handy for checking commutation relations
for example, almost an indispensable time saver.</p><p>Here is a little starter script to help get you going:</p><div class=highlight><pre aria-label="Box containing code sample." tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python3</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sympy</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>galgebra.ga</span> <span class=kn>import</span> <span class=n>Ga</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>galgebra.printer</span> <span class=kn>import</span> <span class=n>latex</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;Define some of the Matrix Pauli algebra&#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>realpart</span><span class=p>(</span><span class=n>z</span><span class=p>):</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>z</span><span class=o>.</span><span class=n>as_real_imag</span><span class=p>()[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>imagpart</span><span class=p>(</span><span class=n>z</span><span class=p>):</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>z</span><span class=o>.</span><span class=n>as_real_imag</span><span class=p>()[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a0</span><span class=p>,</span><span class=n>a1</span><span class=p>,</span><span class=n>a2</span><span class=p>,</span><span class=n>a3</span> <span class=o>=</span> <span class=n>sympy</span><span class=o>.</span><span class=n>symbols</span><span class=p>(</span><span class=s1>&#39;a0,a1,a2,a3&#39;</span><span class=p>,</span> <span class=n>real</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p0</span> <span class=o>=</span> <span class=n>sympy</span><span class=o>.</span><span class=n>Matrix</span><span class=p>([[</span><span class=mf>1.</span><span class=p>,</span><span class=mf>0.</span><span class=p>],[</span><span class=mf>0.</span><span class=p>,</span><span class=mf>1.</span><span class=p>]])</span>
</span></span><span class=line><span class=cl><span class=n>p1</span> <span class=o>=</span> <span class=n>sympy</span><span class=o>.</span><span class=n>Matrix</span><span class=p>([[</span><span class=mf>0.</span><span class=p>,</span><span class=mf>1.</span><span class=p>],[</span><span class=mf>1.</span><span class=p>,</span><span class=mf>0.</span><span class=p>]])</span>
</span></span><span class=line><span class=cl><span class=n>p2</span> <span class=o>=</span> <span class=n>sympy</span><span class=o>.</span><span class=n>Matrix</span><span class=p>([[</span><span class=mf>0.</span><span class=p>,</span><span class=o>-</span><span class=mi>1</span><span class=n>j</span><span class=p>],[</span><span class=mi>1</span><span class=n>j</span><span class=p>,</span><span class=mf>0.</span><span class=p>]])</span>
</span></span><span class=line><span class=cl><span class=n>p3</span> <span class=o>=</span> <span class=n>sympy</span><span class=o>.</span><span class=n>Matrix</span><span class=p>([[</span><span class=mf>1.</span><span class=p>,</span><span class=mf>0.</span><span class=p>],[</span><span class=mf>0.</span><span class=p>,</span><span class=o>-</span><span class=mf>1.</span><span class=p>]])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Psi</span> <span class=o>=</span> <span class=n>sympy</span><span class=o>.</span><span class=n>Matrix</span><span class=p>([[</span><span class=n>a0</span><span class=o>+</span><span class=mi>1</span><span class=n>j</span><span class=o>*</span><span class=n>a3</span><span class=p>],[</span><span class=o>-</span><span class=n>a2</span><span class=o>+</span><span class=mi>1</span><span class=n>j</span><span class=o>*</span><span class=n>a1</span><span class=p>]])</span>
</span></span><span class=line><span class=cl><span class=n>p1Psi</span> <span class=o>=</span> <span class=n>p1</span> <span class=o>*</span> <span class=n>Psi</span>
</span></span><span class=line><span class=cl><span class=n>p2Psi</span> <span class=o>=</span> <span class=n>p2</span> <span class=o>*</span> <span class=n>Psi</span>
</span></span><span class=line><span class=cl><span class=n>p3Psi</span> <span class=o>=</span> <span class=n>p3</span> <span class=o>*</span> <span class=n>Psi</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>GAlgebra little test
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>NOTE: we are redefining the s1, s2 by re-using the a_0, a1,...
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=p>)</span> <span class=o>=</span> <span class=n>sympy</span><span class=o>.</span><span class=n>symbols</span><span class=p>(</span><span class=s1>&#39;t x y z&#39;</span><span class=p>,</span> <span class=n>real</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>o4d</span> <span class=o>=</span> <span class=n>Ga</span><span class=p>(</span><span class=s1>&#39;e_t e_x e_y e_z&#39;</span><span class=p>,</span> <span class=n>g</span><span class=o>=</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span> <span class=n>coords</span><span class=o>=</span><span class=n>txyz</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>e0</span><span class=p>,</span> <span class=n>e1</span><span class=p>,</span> <span class=n>e2</span><span class=p>,</span> <span class=n>e3</span> <span class=o>=</span> <span class=n>o4d</span><span class=o>.</span><span class=n>mv</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>ips</span> <span class=o>=</span> <span class=n>o4d</span><span class=o>.</span><span class=n>I</span><span class=p>()</span>    <span class=c1># same as e0*e1*e2*e3</span>
</span></span><span class=line><span class=cl><span class=n>s1</span> <span class=o>=</span> <span class=n>e0</span><span class=o>*</span><span class=n>e1</span>
</span></span><span class=line><span class=cl><span class=n>s2</span> <span class=o>=</span> <span class=n>e0</span><span class=o>*</span><span class=n>e2</span>
</span></span><span class=line><span class=cl><span class=n>s3</span> <span class=o>=</span> <span class=n>e0</span><span class=o>*</span><span class=n>e3</span>
</span></span><span class=line><span class=cl><span class=n>psi</span> <span class=o>=</span> <span class=n>a0</span> <span class=o>+</span> <span class=n>a1</span><span class=o>*</span><span class=n>ips</span><span class=o>*</span><span class=n>s1</span> <span class=o>+</span> <span class=n>a2</span><span class=o>*</span><span class=n>ips</span><span class=o>*</span><span class=n>s2</span> <span class=o>+</span> <span class=n>a3</span><span class=o>*</span><span class=n>ips</span><span class=o>*</span><span class=n>s3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Sympy GALGEBRA testing&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=mi>22</span><span class=o>*</span><span class=s1>&#39;=&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Test 1. cyclic si.sj == I.sk&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=mi>28</span><span class=o>*</span><span class=s1>&#39;-&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s1</span><span class=o>*</span><span class=n>s2</span> <span class=o>==</span> <span class=n>ips</span><span class=o>*</span><span class=n>s3</span>
</span></span><span class=line><span class=cl><span class=n>s1</span><span class=o>*</span><span class=n>s2</span> <span class=o>==</span> <span class=n>ips</span><span class=o>*</span><span class=n>s3</span>
</span></span><span class=line><span class=cl><span class=n>s1</span><span class=o>*</span><span class=n>s2</span> <span class=o>==</span> <span class=n>ips</span><span class=o>*</span><span class=n>s3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Test 2. cyclic [si, sj] == 2.I.sk&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=mi>33</span><span class=o>*</span><span class=s1>&#39;-&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s1</span><span class=o>*</span><span class=n>s2</span><span class=o>-</span><span class=n>s2</span><span class=o>*</span><span class=n>s1</span> <span class=o>==</span> <span class=mi>2</span><span class=o>*</span><span class=n>ips</span><span class=o>*</span><span class=n>s3</span>
</span></span><span class=line><span class=cl><span class=n>s2</span><span class=o>*</span><span class=n>s3</span><span class=o>-</span><span class=n>s3</span><span class=o>*</span><span class=n>s2</span> <span class=o>==</span> <span class=mi>2</span><span class=o>*</span><span class=n>ips</span><span class=o>*</span><span class=n>s1</span>
</span></span><span class=line><span class=cl><span class=n>s3</span><span class=o>*</span><span class=n>s1</span><span class=o>-</span><span class=n>s1</span><span class=o>*</span><span class=n>s3</span> <span class=o>==</span> <span class=mi>2</span><span class=o>*</span><span class=n>ips</span><span class=o>*</span><span class=n>s2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Test 3. Checking s1.psi.s3&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=mi>28</span><span class=o>*</span><span class=s1>&#39;-&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s1_psi</span> <span class=o>=</span> <span class=n>s1</span><span class=o>*</span><span class=n>psi</span><span class=o>*</span><span class=n>s3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>psi1_blades</span> <span class=o>=</span> <span class=n>s1_psi</span><span class=o>.</span><span class=n>blade_coefs</span><span class=p>([</span><span class=n>ips</span><span class=o>*</span><span class=n>s1</span><span class=p>,</span> <span class=o>-</span><span class=n>ips</span><span class=o>*</span><span class=n>s2</span><span class=p>,</span> <span class=n>ips</span><span class=o>*</span><span class=n>s3</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Is s1.psi.s3.grade(0) == -a2&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s1_psi</span><span class=o>.</span><span class=n>grade</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=n>realpart</span><span class=p>(</span><span class=n>p1Psi</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span><span class=o>*</span><span class=n>e1</span><span class=o>*</span><span class=n>e1</span>
</span></span><span class=line><span class=cl><span class=n>psi1_blades</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>*</span><span class=n>ips</span><span class=o>*</span><span class=n>s1</span> <span class=o>==</span> <span class=n>imagpart</span><span class=p>(</span><span class=n>p1Psi</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span><span class=o>*</span><span class=n>ips</span><span class=o>*</span><span class=n>s1</span>
</span></span><span class=line><span class=cl><span class=n>psi1_blades</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>*</span><span class=p>(</span><span class=o>-</span><span class=n>ips</span><span class=o>*</span><span class=n>s2</span><span class=p>)</span>  <span class=o>==</span> <span class=n>realpart</span><span class=p>(</span><span class=n>p1Psi</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span><span class=o>*</span><span class=p>(</span><span class=o>-</span><span class=n>ips</span><span class=o>*</span><span class=n>s2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>psi1_blades</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=o>*</span><span class=n>ips</span><span class=o>*</span><span class=n>s3</span> <span class=o>==</span> <span class=n>imagpart</span><span class=p>(</span><span class=n>p1Psi</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span><span class=o>*</span><span class=p>(</span><span class=n>ips</span><span class=o>*</span><span class=n>s3</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=kingdon-geometric-algebra><a class=anchor href=#kingdon-geometric-algebra title='Anchor for: kingdon Geometric Algebra.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>kingdon Geometric Algebra</h3><p>Recently I found an alternative Python library for projective galgebra. It is
called <a href=https://kingdon.readthedocs.io/en/latest/readme.html target=_blank>kingdon</a>
.
Unfortunately it doesn&rsquo;t seem to be as powerful for general purposes
as <code>gealgebra</code>, for example <code>kingdon</code> cannot exponentiate to give us rotors.</p><p>However, the use case for <code>kingdon</code> is projective geometry, so it&rsquo;s all points
and lines anyhow, and you rotate by a double reflection, so all you need for
that are the two lines. I guess you could define a custom exponentiator that
way (sandwich product given two lines). Also <code>kingdon</code> can do conformal geometry,
so can include spheres.</p><p>Installing from bash:</p><pre aria-label="Box containing code sample." tabindex=0><code>pip3 install kingdon
</code></pre><p>It has numba numerical acceleration, and uses sympy for symbolic algebra.</p><div class=highlight><pre aria-label="Box containing code sample." tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=kn>from</span> <span class=nn>kingdon</span> <span class=kn>import</span> <span class=n>Algebra</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>alg</span> <span class=o>=</span> <span class=n>Algebra</span><span class=p>(</span><span class=n>p</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=n>q</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>r</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>locals</span><span class=p>()</span><span class=o>.</span><span class=n>update</span><span class=p>(</span><span class=n>alg</span><span class=o>.</span><span class=n>blades</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>e</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>*</span> <span class=n>e1</span> <span class=o>-</span> <span class=mi>5</span> <span class=o>*</span> <span class=n>e2</span> <span class=o>+</span> <span class=mi>6</span> <span class=o>*</span> <span class=n>e12</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>y</span> <span class=o>=</span> <span class=mf>1.5</span><span class=o>*</span><span class=n>e2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>print</span><span class=p>(</span><span class=n>x</span><span class=o>^</span><span class=n>y</span><span class=p>)</span>  <span class=c1># outer product</span>
</span></span><span class=line><span class=cl><span class=mf>3.0</span> <span class=n>𝐞₂</span> <span class=o>+</span> <span class=mf>1.5</span> <span class=n>𝐞₁₂</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>print</span><span class=p>(</span><span class=n>x</span><span class=o>|</span><span class=n>y</span><span class=p>)</span>  <span class=c1># inner product</span>
</span></span><span class=line><span class=cl><span class=o>-</span><span class=mf>7.5</span> <span class=o>+</span> <span class=mf>9.0</span> <span class=n>𝐞₁</span> <span class=o>+</span> <span class=mf>3.0</span> <span class=n>𝐞₂</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>print</span><span class=p>(</span><span class=n>x</span><span class=o>*</span><span class=n>y</span><span class=p>)</span>  <span class=c1># geometric product</span>
</span></span><span class=line><span class=cl><span class=o>-</span><span class=mf>7.5</span> <span class=o>+</span> <span class=mf>9.0</span> <span class=n>𝐞₁</span> <span class=o>+</span> <span class=mf>3.0</span> <span class=n>𝐞₂</span> <span class=o>+</span> <span class=mf>1.5</span> <span class=n>𝐞₁₂</span>
</span></span></code></pre></div><p>A super useful feature of <code>kingdon</code> is that it supports computation in
<strong>Projective GA</strong>. For this you would use an algebra defined with a
null basis vector, so for 3D Euclidean PGA:</p><div class=highlight><pre aria-label="Box containing code sample." tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>alg</span> <span class=o>=</span> <span class=n>Algebra</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>The advantage of computing in PGA is that all rigid rotations are the same in
any dimension, as are meets, as are joins, as are projections, and all of these
are simple expressions involving the outer product, the regressor product, the
projection operation:
$$
(A\cdot B) B
$$
and the sandwhich product (for rigid transforms):
$$
R^\dagger A R
$$
the latter expression being the single universal expression for all rotations
and translations.</p><p>MathTuber
<a href=https://www.youtube.com/@sudgylacmoe target=_blank>sudgylacmoe</a>
has a lovely tutorial on
<a href="https://www.youtube.com/watch?v=0i3ocLhbxJ4" target=_blank>2DPGA and 3DPGA</a>
.</p><p>Although I think I will stick to <code>galgebra</code>, let&rsquo;s at least try a simple
rotation.</p><div class=highlight><pre aria-label="Box containing code sample." tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>numpy</span> <span class=kn>import</span> <span class=n>pi</span><span class=p>,</span> <span class=n>sqrt</span><span class=p>,</span> <span class=n>sin</span><span class=p>,</span> <span class=n>cos</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>e1</span>
</span></span><span class=line><span class=cl><span class=n>theta</span> <span class=o>=</span> <span class=n>pi</span> <span class=o>/</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>n</span> <span class=o>=</span> <span class=mi>1</span><span class=o>/</span><span class=n>sqrt</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>e1</span> <span class=o>+</span> <span class=n>e2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>mx</span> <span class=o>=</span> <span class=n>cos</span><span class=p>(</span> <span class=n>theta</span><span class=o>/</span><span class=mi>2</span> <span class=p>)</span> <span class=o>*</span> <span class=n>e2</span>
</span></span><span class=line><span class=cl><span class=n>my</span> <span class=o>=</span> <span class=n>sin</span><span class=p>(</span> <span class=n>theta</span><span class=o>/</span><span class=mi>2</span> <span class=p>)</span> <span class=o>*</span> <span class=n>e1</span>
</span></span><span class=line><span class=cl><span class=n>m</span> <span class=o>=</span> <span class=n>mx</span> <span class=o>+</span> <span class=n>my</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>print</span><span class=p>(</span><span class=n>m</span><span class=o>*</span><span class=n>n</span><span class=o>*</span><span class=n>a</span><span class=o>*</span><span class=n>n</span><span class=o>*</span><span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=mf>1.41</span> <span class=n>𝐞₁</span> <span class=o>+</span> <span class=mf>1.41</span> <span class=n>𝐞₂</span>
</span></span></code></pre></div><p>I haven&rsquo;t given much thought to how to construct a pair of unit lines like the
above <code>n</code> and <code>m</code> given a unit bivector and an angle, but I guess it could
be done efficiently. Then we could define exponentiation of bivectors at least,
hence rotors. But why bother? <code>galgebra</code> gives us the power. One promise made by
<code>kingdon</code> is numerical computation speed using <code>numba</code>, so if we say get into solving
the Dirac equation then maybe it&rsquo;d come in handy.</p><h3 id=julia-multivectors><a class=anchor href=#julia-multivectors title='Anchor for: Julia Multivectors.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Julia Multivectors</h3><p>If you want slightly faster numerics, try either</p><ul><li><a href=https://monumoltd.github.io/SimpleGA.jl/dev/ target=_blank>SimpleGA</a>
&mdash; this was
developed by Chris Doran for robotics and other computer applications, so
I&rsquo;d say is highly recommended.</li><li>Or <a href=https://docs.julialang.org/ target=_blank>Multivectors.jl</a>
package <a href=https://github.com/digitaldomain/Multivectors.jl target=_blank>Mutivectors.jl</a>
&mdash; I found this one a bit clunky.</li></ul><p>To install Julia differs from platform to platform, my install used the
latest Linux tarball for Intel chips:</p><div class=highlight><pre aria-label="Box containing code sample." tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ mkdir /opt/julia <span class=o>&amp;&amp;</span> <span class=nb>cd</span> /opt/julia/
</span></span><span class=line><span class=cl>$ wget https://julialang-s3.julialang.org/bin/linux/x64/1.9/julia-1.9.3-linux-x86_64.tar.gz
</span></span><span class=line><span class=cl>$ tar zxvf julia-1.8.3-linux-x86_64.tar.gz
</span></span><span class=line><span class=cl>$ ln -s /opt/julia/julia-1.8.3/bin/julia /home/geon/.local/bin/
</span></span><span class=line><span class=cl>$ julia
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>For SimpleGA:</p><div class=highlight><pre aria-label="Box containing code sample." tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=o>$</span> <span class=n>julialang</span>
</span></span><span class=line><span class=cl><span class=n>julia</span><span class=o>&gt;</span> <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nd>@v1</span><span class=mf>.9</span><span class=p>)</span> <span class=n>pkg</span><span class=o>&gt;</span>  <span class=n>add</span> <span class=n>SimpleGA</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=c># (to exit pkg&gt; mode you hit Backspace on your keyboard)</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=n>julia</span><span class=o>&gt;</span> <span class=k>using</span> <span class=n>LinearAlgebra</span>
</span></span><span class=line><span class=cl><span class=n>julia</span><span class=o>&gt;</span> <span class=k>using</span> <span class=n>SimpleGA</span>
</span></span><span class=line><span class=cl><span class=n>julia</span><span class=o>&gt;</span> <span class=n>e</span> <span class=o>=</span> <span class=n>GA20</span><span class=o>.</span><span class=n>basis</span>
</span></span><span class=line><span class=cl><span class=mi>2</span><span class=o>-</span><span class=n>element</span> <span class=n>StaticArraysCore</span><span class=o>.</span><span class=kt>SVector</span><span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=kt>SimpleGA</span><span class=o>.</span><span class=kt>GA20</span><span class=o>.</span><span class=kt>Odd</span><span class=p>{</span><span class=kt>Int8</span><span class=p>}}</span> <span class=n>with</span> <span class=n>indices</span> <span class=n>SOneTo</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl> <span class=mf>1e1</span>
</span></span><span class=line><span class=cl> <span class=mf>1e2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>julia</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=n>e</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>e</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=mf>1e1</span> <span class=o>+</span> <span class=mf>1e2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>julia</span><span class=o>&gt;</span> <span class=n>b</span> <span class=o>=</span> <span class=mf>2.0</span><span class=o>*</span><span class=n>e</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>3</span><span class=o>*</span><span class=n>e</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> 
</span></span><span class=line><span class=cl><span class=mf>2.0e1</span> <span class=o>+</span> <span class=mf>3.0e2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>julia</span><span class=o>&gt;</span> <span class=n>a</span><span class=o>*</span><span class=n>b</span>  <span class=c># Evaluates the geometric product of a and b.</span>
</span></span><span class=line><span class=cl><span class=mf>5.0</span> <span class=o>+</span> <span class=mf>1.0</span><span class=n>I2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>julia</span><span class=o>&gt;</span> 
</span></span></code></pre></div><p>For Multivector.js:</p><div class=highlight><pre aria-label="Box containing code sample." tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>julia</span><span class=o>&gt;</span> <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nd>@v1</span><span class=mf>.9</span><span class=p>)</span> <span class=n>pkg</span><span class=o>&gt;</span> <span class=n>registry</span> <span class=n>add</span>
</span></span><span class=line><span class=cl><span class=n>julia</span><span class=o>&gt;</span> <span class=k>import</span> <span class=n>Multivectors</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=n>julia</span><span class=o>&gt;</span> <span class=k>using</span> <span class=n>Multivectors</span>
</span></span><span class=line><span class=cl><span class=n>julia</span><span class=o>&gt;</span> <span class=nd>@generate_basis</span><span class=p>(</span><span class=s>&#34;+++&#34;</span><span class=p>,</span> <span class=nb>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>julia</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=mf>0.0</span><span class=n>e₁</span><span class=o>+</span><span class=mf>0.0</span><span class=n>e₂</span><span class=p>;</span> <span class=n>b</span> <span class=o>=</span> <span class=mf>1.0</span><span class=n>e₁</span> <span class=o>+</span> <span class=mf>0.0</span><span class=n>e₂</span><span class=p>;</span> <span class=n>c</span> <span class=o>=</span> <span class=mf>0.0</span><span class=n>e₁</span> <span class=o>+</span> <span class=mf>1.0</span><span class=n>e₂</span><span class=p>;</span>  <span class=c># a simple right angle triangle</span>
</span></span><span class=line><span class=cl><span class=n>julia</span><span class=o>&gt;</span> <span class=n>A</span> <span class=o>=</span> <span class=p>(</span><span class=n>b</span><span class=o>-</span><span class=n>a</span><span class=p>)</span><span class=o>∧</span><span class=p>(</span><span class=n>c</span><span class=o>-</span><span class=n>a</span><span class=p>)</span>  <span class=c># twice the area of the triangle, but with oreintation info. </span>
</span></span><span class=line><span class=cl><span class=mf>1.0</span><span class=n>e₁₂</span>
</span></span></code></pre></div><h2 id=caveats><a class=anchor href=#caveats title='Anchor for: Caveats.'><svg aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#hashtag"/></svg></a>Caveats</h2><p>I am trying to limit the mathematical verbiage, but this means more plain
English than a traditional textbook. However, I am also trying to limit
the length of these articles. It is likely that some readers will feel there
is missing content or a few
big skips over crucial concepts or mathematical development.
If you feel that is strongly the case, please note exactly what you think
is missing and <a href=https://ko-fi.com/achrononmaster/ target=_blank>sign-up for donations,</a><br>then give yourself licence to email me about your notes. That goes double
for any errors you find. If you find an error just email me and do not
even worry about donating cash.</p><p>If you donate via <a href=https://ko-fi.com/achrononmaster/ target=_blank>Ko-fi.</a>
I will take into
consideration your comments.</p><table style="border-collapse:collapse;border=0"><col span=1 style=width:25%><col span=1 style=width:35%><col span=1 style=width:25%><tr style="border:1px solid color:#0f0f0f"><td style="border:1px solid color:#0f0f0f"><a href=../003_wigner>Previous</a></td><td style="border:1px solid color:#0f0f0f;text-align:center"><a href=../>Back to Theory</a></td><td style="border:1px solid color:#0f0f0f;text-align:right"><a href=../005_spacetime_algebra>Next chapter</a></td></tr><tr style="border:1px solid color:#0f0f0f"><td style="border:1px solid color:#0f0f0f"><a href=../003_wigner>Wigner and Particles</a></td><td style="border:1px solid color:#0f0f0f;text-align:center"><a href=../>TOC</a></td><td style="border:1px solid color:#0f0f0f;text-align:right"><a href=../005_spacetime_algebra>Spacetime Algebra</a></td></tr></table></article></main></div><footer><div class=req-js><button class=outline-dashed title="Change to light/dark mode."><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><use xlink:href="/t4gu/img/bundle.min.fc89b321aa39dfb355170fc007ce5b94.svg#adjust"/></svg></button><input class=outline-dashed type=color list=presets value=#26A269 title="Change accent color." aria-label="Change accent color."><datalist id=presets><option value=#1f676b><option value=#26A269><option value=#225670><option value=#dd587c><option value=#902b37><option value=#f3a530><option value=#754e85><option value=#7fc121><option value=#a8314a><option value=#ff7433><option value=#3e6728><option value=#c063bd><option value=#805080><option value=#9d629d><option value=#a064a0><option value=#7daa50><option value=#284531><option value=#285790><option value=#F5A83D><option value=#88aa33><option value=#015660><option value=#bf274e><option value=#bf4242><option value=#51b37c></datalist></div><noscript><p class=noscript>Unable to execute JavaScript. Some features were disabled.</p></noscript></footer><link rel=stylesheet href=https://t4gu.gitlab.io/t4gu/libs/katex@0.16.0/dist/katex.min.6950e59dbd8dfddd111390d85888bb5f9dc2e9c334da7ac1c3bacc92a695610d.css integrity="sha256-aVDlnb2N/d0RE5DYWIi7X53C6cM02nrBw7rMkqaVYQ0=" crossorigin=anonymous><script defer src=https://t4gu.gitlab.io/t4gu/libs/katex@0.16.0/dist/katex.min.0ef45cd8f7b6109cb7d8fd21b5a999fa3a6353d7c8b817b13f24fa66136c32d9.js integrity="sha256-DvRc2Pe2EJy32P0htamZ+jpjU9fIuBexPyT6ZhNsMtk=" crossorigin=anonymous></script><script defer src=https://t4gu.gitlab.io/t4gu/js/katex-custom-render.min.c40a327c961fc9259dd10a48b4276e7e24fcd8baa1a1e028f68273f4cbe8ce8a.js integrity="sha256-xAoyfJYfySWd0QpItCdufiT82LqhoeAo9oJz9Mvozoo=" crossorigin=anonymous></script></body></html>